{"ast":null,"code":"import { gridMap as $1af922eb41e03c8f$export$e6235c0d09b995d0 } from \"./utils.mjs\";\nimport { getFocusableTreeWalker as $j4Qbl$getFocusableTreeWalker, focusSafely as $j4Qbl$focusSafely } from \"@react-aria/focus\";\nimport { scrollIntoViewport as $j4Qbl$scrollIntoViewport, getScrollParent as $j4Qbl$getScrollParent, mergeProps as $j4Qbl$mergeProps } from \"@react-aria/utils\";\nimport { isFocusVisible as $j4Qbl$isFocusVisible } from \"@react-aria/interactions\";\nimport { useRef as $j4Qbl$useRef } from \"react\";\nimport { useLocale as $j4Qbl$useLocale } from \"@react-aria/i18n\";\nimport { useSelectableItem as $j4Qbl$useSelectableItem } from \"@react-aria/selection\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {\n  let {\n    node: node,\n    isVirtualized: isVirtualized,\n    focusMode = \"child\",\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onAction\n  } = props;\n  let {\n    direction: direction\n  } = (0, $j4Qbl$useLocale)();\n  let {\n    keyboardDelegate: keyboardDelegate,\n    actions: {\n      onCellAction: onCellAction\n    }\n  } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);\n  // We need to track the key of the item at the time it was last focused so that we force\n  // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n  let keyWhenFocused = (0, $j4Qbl$useRef)(null);\n  // Handles focusing the cell. If there is a focusable child,\n  // it is focused, otherwise the cell itself is focused.\n  let focus = () => {\n    let treeWalker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n    if (focusMode === \"child\") {\n      // If focus is already on a focusable child within the cell, early return so we don't shift focus\n      if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) return;\n      let focusable = state.selectionManager.childFocusStrategy === \"last\" ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();\n      if (focusable) {\n        (0, $j4Qbl$focusSafely)(focusable);\n        return;\n      }\n    }\n    if (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement)) (0, $j4Qbl$focusSafely)(ref.current);\n  };\n  let {\n    itemProps: itemProps,\n    isPressed: isPressed\n  } = (0, $j4Qbl$useSelectableItem)({\n    selectionManager: state.selectionManager,\n    key: node.key,\n    ref: ref,\n    isVirtualized: isVirtualized,\n    focus: focus,\n    shouldSelectOnPressUp: shouldSelectOnPressUp,\n    onAction: onCellAction ? () => onCellAction(node.key) : onAction,\n    isDisabled: state.collection.size === 0\n  });\n  let onKeyDownCapture = e => {\n    if (!e.currentTarget.contains(e.target) || state.isKeyboardNavigationDisabled) return;\n    let walker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n    walker.currentNode = document.activeElement;\n    switch (e.key) {\n      case \"ArrowLeft\":\n        {\n          // Find the next focusable element within the cell.\n          let focusable = direction === \"rtl\" ? walker.nextNode() : walker.previousNode();\n          // Don't focus the cell itself if focusMode is \"child\"\n          if (focusMode === \"child\" && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            // If there is no next focusable child, then move to the next cell to the left of this one.\n            // This will be handled by useSelectableCollection. However, if there is no cell to the left\n            // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n            // same as this one. In that case we need to handle focusing either the cell or the first/last\n            // child, depending on the focus mode.\n            let prev = keyboardDelegate.getKeyLeftOf(node.key);\n            if (prev !== node.key) {\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === \"cell\" && direction === \"rtl\") {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === \"rtl\" ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case \"ArrowRight\":\n        {\n          let focusable = direction === \"rtl\" ? walker.previousNode() : walker.nextNode();\n          if (focusMode === \"child\" && focusable === ref.current) focusable = null;\n          e.preventDefault();\n          e.stopPropagation();\n          if (focusable) {\n            (0, $j4Qbl$focusSafely)(focusable);\n            (0, $j4Qbl$scrollIntoViewport)(focusable, {\n              containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n            });\n          } else {\n            let next = keyboardDelegate.getKeyRightOf(node.key);\n            if (next !== node.key) {\n              // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n              // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n              // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n              ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n              break;\n            }\n            if (focusMode === \"cell\" && direction === \"ltr\") {\n              (0, $j4Qbl$focusSafely)(ref.current);\n              (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n              });\n            } else {\n              walker.currentNode = ref.current;\n              focusable = direction === \"rtl\" ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();\n              if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                  containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                });\n              }\n            }\n          }\n          break;\n        }\n      case \"ArrowUp\":\n      case \"ArrowDown\":\n        // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n        // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n        // bubbles and gets handled by useSelectableCollection.\n        if (!e.altKey && ref.current.contains(e.target)) {\n          e.stopPropagation();\n          e.preventDefault();\n          ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n        }\n        break;\n    }\n  };\n  // Grid cells can have focusable elements inside them. In this case, focus should\n  // be marshalled to that element rather than focusing the cell itself.\n  let onFocus = e => {\n    keyWhenFocused.current = node.key;\n    if (e.target !== ref.current) {\n      // useSelectableItem only handles setting the focused key when\n      // the focused element is the gridcell itself. We also want to\n      // set the focused key when a child element receives focus.\n      // If focus is currently visible (e.g. the user is navigating with the keyboard),\n      // then skip this. We want to restore focus to the previously focused row/cell\n      // in that case since the table should act like a single tab stop.\n      if (!(0, $j4Qbl$isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);\n      return;\n    }\n    // If the cell itself is focused, wait a frame so that focus finishes propagatating\n    // up to the tree, and move focus to a focusable child if possible.\n    requestAnimationFrame(() => {\n      if (focusMode === \"child\" && document.activeElement === ref.current) focus();\n    });\n  };\n  let gridCellProps = (0, $j4Qbl$mergeProps)(itemProps, {\n    role: \"gridcell\",\n    onKeyDownCapture: onKeyDownCapture,\n    onFocus: onFocus\n  });\n  var _node_colIndex;\n  if (isVirtualized) gridCellProps[\"aria-colindex\"] = ((_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index) + 1; // aria-colindex is 1-based\n  // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n  // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n  // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n  // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n  if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = e => {\n    let el = e.currentTarget;\n    let tabindex = el.getAttribute(\"tabindex\");\n    el.removeAttribute(\"tabindex\");\n    requestAnimationFrame(() => {\n      el.setAttribute(\"tabindex\", tabindex);\n    });\n  };\n  return {\n    gridCellProps: gridCellProps,\n    isPressed: isPressed\n  };\n}\nfunction $ab90dcbc1b5466d0$var$last(walker) {\n  let next;\n  let last;\n  do {\n    last = walker.lastChild();\n    if (last) next = last;\n  } while (last);\n  return next;\n}\nexport { $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c as useGridCell };","map":{"version":3,"names":["gridMap","$1af922eb41e03c8f$export$e6235c0d09b995d0","getFocusableTreeWalker","$j4Qbl$getFocusableTreeWalker","focusSafely","$j4Qbl$focusSafely","scrollIntoViewport","$j4Qbl$scrollIntoViewport","getScrollParent","$j4Qbl$getScrollParent","mergeProps","$j4Qbl$mergeProps","isFocusVisible","$j4Qbl$isFocusVisible","useRef","$j4Qbl$useRef","useLocale","$j4Qbl$useLocale","useSelectableItem","$j4Qbl$useSelectableItem","$ab90dcbc1b5466d0$export$c7e10bfc0c59f67c","props","state","ref","node","isVirtualized","focusMode","shouldSelectOnPressUp","onAction","direction","keyboardDelegate","actions","onCellAction","get","keyWhenFocused","focus","treeWalker","current","contains","document","activeElement","focusable","selectionManager","childFocusStrategy","$ab90dcbc1b5466d0$var$last","firstChild","key","itemProps","isPressed","isDisabled","collection","size","onKeyDownCapture","e","currentTarget","target","isKeyboardNavigationDisabled","walker","currentNode","nextNode","previousNode","preventDefault","stopPropagation","containingElement","prev","getKeyLeftOf","parentElement","dispatchEvent","KeyboardEvent","nativeEvent","type","next","getKeyRightOf","altKey","onFocus","setFocusedKey","requestAnimationFrame","gridCellProps","role","_node_colIndex","colIndex","index","tabIndex","onPointerDown","el","tabindex","getAttribute","removeAttribute","setAttribute","last","lastChild","useGridCell"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-aria/grid/dist/useGridCell.mjs"],"sourcesContent":["import {gridMap as $1af922eb41e03c8f$export$e6235c0d09b995d0} from \"./utils.mjs\";\nimport {getFocusableTreeWalker as $j4Qbl$getFocusableTreeWalker, focusSafely as $j4Qbl$focusSafely} from \"@react-aria/focus\";\nimport {scrollIntoViewport as $j4Qbl$scrollIntoViewport, getScrollParent as $j4Qbl$getScrollParent, mergeProps as $j4Qbl$mergeProps} from \"@react-aria/utils\";\nimport {isFocusVisible as $j4Qbl$isFocusVisible} from \"@react-aria/interactions\";\nimport {useRef as $j4Qbl$useRef} from \"react\";\nimport {useLocale as $j4Qbl$useLocale} from \"@react-aria/i18n\";\nimport {useSelectableItem as $j4Qbl$useSelectableItem} from \"@react-aria/selection\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\n\nfunction $ab90dcbc1b5466d0$export$c7e10bfc0c59f67c(props, state, ref) {\n    let { node: node, isVirtualized: isVirtualized, focusMode: focusMode = \"child\", shouldSelectOnPressUp: shouldSelectOnPressUp, onAction: onAction } = props;\n    let { direction: direction } = (0, $j4Qbl$useLocale)();\n    let { keyboardDelegate: keyboardDelegate, actions: { onCellAction: onCellAction } } = (0, $1af922eb41e03c8f$export$e6235c0d09b995d0).get(state);\n    // We need to track the key of the item at the time it was last focused so that we force\n    // focus to go to the item when the DOM node is reused for a different item in a virtualizer.\n    let keyWhenFocused = (0, $j4Qbl$useRef)(null);\n    // Handles focusing the cell. If there is a focusable child,\n    // it is focused, otherwise the cell itself is focused.\n    let focus = ()=>{\n        let treeWalker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n        if (focusMode === \"child\") {\n            // If focus is already on a focusable child within the cell, early return so we don't shift focus\n            if (ref.current.contains(document.activeElement) && ref.current !== document.activeElement) return;\n            let focusable = state.selectionManager.childFocusStrategy === \"last\" ? $ab90dcbc1b5466d0$var$last(treeWalker) : treeWalker.firstChild();\n            if (focusable) {\n                (0, $j4Qbl$focusSafely)(focusable);\n                return;\n            }\n        }\n        if (keyWhenFocused.current != null && node.key !== keyWhenFocused.current || !ref.current.contains(document.activeElement)) (0, $j4Qbl$focusSafely)(ref.current);\n    };\n    let { itemProps: itemProps, isPressed: isPressed } = (0, $j4Qbl$useSelectableItem)({\n        selectionManager: state.selectionManager,\n        key: node.key,\n        ref: ref,\n        isVirtualized: isVirtualized,\n        focus: focus,\n        shouldSelectOnPressUp: shouldSelectOnPressUp,\n        onAction: onCellAction ? ()=>onCellAction(node.key) : onAction,\n        isDisabled: state.collection.size === 0\n    });\n    let onKeyDownCapture = (e)=>{\n        if (!e.currentTarget.contains(e.target) || state.isKeyboardNavigationDisabled) return;\n        let walker = (0, $j4Qbl$getFocusableTreeWalker)(ref.current);\n        walker.currentNode = document.activeElement;\n        switch(e.key){\n            case \"ArrowLeft\":\n                {\n                    // Find the next focusable element within the cell.\n                    let focusable = direction === \"rtl\" ? walker.nextNode() : walker.previousNode();\n                    // Don't focus the cell itself if focusMode is \"child\"\n                    if (focusMode === \"child\" && focusable === ref.current) focusable = null;\n                    e.preventDefault();\n                    e.stopPropagation();\n                    if (focusable) {\n                        (0, $j4Qbl$focusSafely)(focusable);\n                        (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                            containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                        });\n                    } else {\n                        // If there is no next focusable child, then move to the next cell to the left of this one.\n                        // This will be handled by useSelectableCollection. However, if there is no cell to the left\n                        // of this one, only one column, and the grid doesn't focus rows, then the next key will be the\n                        // same as this one. In that case we need to handle focusing either the cell or the first/last\n                        // child, depending on the focus mode.\n                        let prev = keyboardDelegate.getKeyLeftOf(node.key);\n                        if (prev !== node.key) {\n                            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n                            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n                            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n                            ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n                            break;\n                        }\n                        if (focusMode === \"cell\" && direction === \"rtl\") {\n                            (0, $j4Qbl$focusSafely)(ref.current);\n                            (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                            });\n                        } else {\n                            walker.currentNode = ref.current;\n                            focusable = direction === \"rtl\" ? walker.firstChild() : $ab90dcbc1b5466d0$var$last(walker);\n                            if (focusable) {\n                                (0, $j4Qbl$focusSafely)(focusable);\n                                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                                    containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                                });\n                            }\n                        }\n                    }\n                    break;\n                }\n            case \"ArrowRight\":\n                {\n                    let focusable = direction === \"rtl\" ? walker.previousNode() : walker.nextNode();\n                    if (focusMode === \"child\" && focusable === ref.current) focusable = null;\n                    e.preventDefault();\n                    e.stopPropagation();\n                    if (focusable) {\n                        (0, $j4Qbl$focusSafely)(focusable);\n                        (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                            containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                        });\n                    } else {\n                        let next = keyboardDelegate.getKeyRightOf(node.key);\n                        if (next !== node.key) {\n                            // We prevent the capturing event from reaching children of the cell, e.g. pickers.\n                            // We want arrow keys to navigate to the next cell instead. We need to re-dispatch \n                            // the event from a higher parent so it still bubbles and gets handled by useSelectableCollection.\n                            ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n                            break;\n                        }\n                        if (focusMode === \"cell\" && direction === \"ltr\") {\n                            (0, $j4Qbl$focusSafely)(ref.current);\n                            (0, $j4Qbl$scrollIntoViewport)(ref.current, {\n                                containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                            });\n                        } else {\n                            walker.currentNode = ref.current;\n                            focusable = direction === \"rtl\" ? $ab90dcbc1b5466d0$var$last(walker) : walker.firstChild();\n                            if (focusable) {\n                                (0, $j4Qbl$focusSafely)(focusable);\n                                (0, $j4Qbl$scrollIntoViewport)(focusable, {\n                                    containingElement: (0, $j4Qbl$getScrollParent)(ref.current)\n                                });\n                            }\n                        }\n                    }\n                    break;\n                }\n            case \"ArrowUp\":\n            case \"ArrowDown\":\n                // Prevent this event from reaching cell children, e.g. menu buttons. We want arrow keys to navigate\n                // to the cell above/below instead. We need to re-dispatch the event from a higher parent so it still\n                // bubbles and gets handled by useSelectableCollection.\n                if (!e.altKey && ref.current.contains(e.target)) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    ref.current.parentElement.dispatchEvent(new KeyboardEvent(e.nativeEvent.type, e.nativeEvent));\n                }\n                break;\n        }\n    };\n    // Grid cells can have focusable elements inside them. In this case, focus should\n    // be marshalled to that element rather than focusing the cell itself.\n    let onFocus = (e)=>{\n        keyWhenFocused.current = node.key;\n        if (e.target !== ref.current) {\n            // useSelectableItem only handles setting the focused key when\n            // the focused element is the gridcell itself. We also want to\n            // set the focused key when a child element receives focus.\n            // If focus is currently visible (e.g. the user is navigating with the keyboard),\n            // then skip this. We want to restore focus to the previously focused row/cell\n            // in that case since the table should act like a single tab stop.\n            if (!(0, $j4Qbl$isFocusVisible)()) state.selectionManager.setFocusedKey(node.key);\n            return;\n        }\n        // If the cell itself is focused, wait a frame so that focus finishes propagatating\n        // up to the tree, and move focus to a focusable child if possible.\n        requestAnimationFrame(()=>{\n            if (focusMode === \"child\" && document.activeElement === ref.current) focus();\n        });\n    };\n    let gridCellProps = (0, $j4Qbl$mergeProps)(itemProps, {\n        role: \"gridcell\",\n        onKeyDownCapture: onKeyDownCapture,\n        onFocus: onFocus\n    });\n    var _node_colIndex;\n    if (isVirtualized) gridCellProps[\"aria-colindex\"] = ((_node_colIndex = node.colIndex) !== null && _node_colIndex !== void 0 ? _node_colIndex : node.index) + 1; // aria-colindex is 1-based\n    // When pressing with a pointer and cell selection is not enabled, usePress will be applied to the\n    // row rather than the cell. However, when the row is draggable, usePress cannot preventDefault\n    // on pointer down, so the browser will try to focus the cell which has a tabIndex applied.\n    // To avoid this, remove the tabIndex from the cell briefly on pointer down.\n    if (shouldSelectOnPressUp && gridCellProps.tabIndex != null && gridCellProps.onPointerDown == null) gridCellProps.onPointerDown = (e)=>{\n        let el = e.currentTarget;\n        let tabindex = el.getAttribute(\"tabindex\");\n        el.removeAttribute(\"tabindex\");\n        requestAnimationFrame(()=>{\n            el.setAttribute(\"tabindex\", tabindex);\n        });\n    };\n    return {\n        gridCellProps: gridCellProps,\n        isPressed: isPressed\n    };\n}\nfunction $ab90dcbc1b5466d0$var$last(walker) {\n    let next;\n    let last;\n    do {\n        last = walker.lastChild();\n        if (last) next = last;\n    }while (last);\n    return next;\n}\n\n\nexport {$ab90dcbc1b5466d0$export$c7e10bfc0c59f67c as useGridCell};\n//# sourceMappingURL=useGridCell.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}