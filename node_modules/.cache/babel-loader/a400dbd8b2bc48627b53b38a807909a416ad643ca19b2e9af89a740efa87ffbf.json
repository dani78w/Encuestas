{"ast":null,"code":"import { NumberFormatter as $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 } from \"./NumberFormatter.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp(\"^.*\\\\(.*\\\\).*$\");\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [\"latn\", \"arab\", \"hanidec\"];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n  /**\n  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n  */\n  parse(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n  }\n  /**\n  * Returns whether the given string could potentially be a valid number. This should be used to\n  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n  * of the minus/plus sign characters can be checked.\n  */\n  isValidPartialNumber(value, minValue, maxValue) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n  }\n  /**\n  * Returns a numbering system for which the given string is valid in the current locale.\n  * If no numbering system could be detected, the default numbering system for the current\n  * locale is returned.\n  */\n  getNumberingSystem(value) {\n    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n  }\n  constructor(locale, options = {}) {\n    this.locale = locale;\n    this.options = options;\n  }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n  // First try the default numbering system for the provided locale\n  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n  // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n  // try each of the other supported numbering systems until we find one that matches.\n  if (!locale.includes(\"-nu-\") && !defaultParser.isValidPartialNumber(value)) {\n    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {\n      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes(\"-u-\") ? \"-nu-\" : \"-u-nu-\") + numberingSystem, options);\n      if (parser.isValidPartialNumber(value)) return parser;\n    }\n  }\n  return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n  let cacheKey = locale + (options ? Object.entries(options).sort((a, b) => a[0] < b[0] ? -1 : 1).join() : \"\");\n  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n  if (!parser) {\n    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n  }\n  return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n  parse(value) {\n    // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n    let fullySanitizedValue = this.sanitize(value);\n    if (this.symbols.group)\n      // Remove group characters, and replace decimal points and numerals with ASCII values.\n      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, \"\");\n    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, \".\");\n    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, \"-\");\n    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);\n    if (this.options.style === \"percent\") {\n      // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing\n      let isNegative = fullySanitizedValue.indexOf(\"-\");\n      fullySanitizedValue = fullySanitizedValue.replace(\"-\", \"\");\n      let index = fullySanitizedValue.indexOf(\".\");\n      if (index === -1) index = fullySanitizedValue.length;\n      fullySanitizedValue = fullySanitizedValue.replace(\".\", \"\");\n      if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;else if (index - 2 === -2) fullySanitizedValue = \"0.00\";else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;\n      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;\n    }\n    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n    if (isNaN(newValue)) return NaN;\n    if (this.options.style === \"percent\") {\n      // extra step for rounding percents to what our formatter would output\n      let options = {\n        ...this.options,\n        style: \"decimal\",\n        minimumFractionDigits: Math.min(this.options.minimumFractionDigits + 2, 20),\n        maximumFractionDigits: Math.min(this.options.maximumFractionDigits + 2, 20)\n      };\n      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));\n    }\n    // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n    if (this.options.currencySign === \"accounting\" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n    return newValue;\n  }\n  sanitize(value) {\n    // Remove literals and whitespace, which are allowed anywhere in the string\n    value = value.replace(this.symbols.literals, \"\");\n    // Replace the ASCII minus sign with the minus sign used in the current locale\n    // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n    if (this.symbols.minusSign) value = value.replace(\"-\", this.symbols.minusSign);\n    // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n    // instead they use the , (44) character or apparently the (1548) character.\n    if (this.options.numberingSystem === \"arab\") {\n      if (this.symbols.decimal) {\n        value = value.replace(\",\", this.symbols.decimal);\n        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n      }\n      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, \".\", this.symbols.group);\n    }\n    // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n    // so allow 'period' as a group char and replace it with a space\n    if (this.options.locale === \"fr-FR\") value = $6c7bd7858deea686$var$replaceAll(value, \".\", String.fromCharCode(8239));\n    return value;\n  }\n  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\n    value = this.sanitize(value);\n    // Remove minus or plus sign, which must be at the start of the string.\n    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n    // Numbers cannot start with a group separator\n    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;\n    // Numbers that can't have any decimal values fail if a decimal character is typed\n    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;\n    // Remove numerals, groups, and decimals\n    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, \"\");\n    value = value.replace(this.symbols.numeral, \"\");\n    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, \"\");\n    // The number is valid if there are no remaining characters\n    return value.length === 0;\n  }\n  constructor(locale, options = {}) {\n    this.locale = locale;\n    this.formatter = new Intl.NumberFormat(locale, options);\n    this.options = this.formatter.resolvedOptions();\n    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);\n    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;\n    if (this.options.style === \"percent\" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn(\"NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.\");\n  }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set([\"decimal\", \"fraction\", \"integer\", \"minusSign\", \"plusSign\", \"group\"]);\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst $6c7bd7858deea686$var$pluralNumbers = [0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1];\nfunction $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {\n  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;\n  // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set\n  let symbolFormatter = new Intl.NumberFormat(locale, {\n    ...intlOptions,\n    minimumSignificantDigits: 1,\n    maximumSignificantDigits: 21\n  });\n  // Note: some locale's don't add a group symbol until there is a ten thousands place\n  let allParts = symbolFormatter.formatToParts(-10000.111);\n  let posAllParts = symbolFormatter.formatToParts(10000.111);\n  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map(n => symbolFormatter.formatToParts(n));\n  var _allParts_find_value;\n  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find(p => p.type === \"minusSign\")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : \"-\";\n  let plusSign = (_posAllParts_find = posAllParts.find(p => p.type === \"plusSign\")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;\n  // Safari does not support the signDisplay option, but our number parser polyfills it.\n  // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n  // @ts-ignore\n  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"exceptZero\" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"always\")) plusSign = \"+\";\n  // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters\n  // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal\n  let decimalParts = new Intl.NumberFormat(locale, {\n    ...intlOptions,\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  }).formatToParts(0.001);\n  let decimal = (_decimalParts_find = decimalParts.find(p => p.type === \"decimal\")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;\n  let group = (_allParts_find1 = allParts.find(p => p.type === \"group\")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;\n  // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n  // don't contribute to the numerical value\n  let allPartsLiterals = allParts.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value));\n  let pluralPartsLiterals = pluralParts.flatMap(p => p.filter(p => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map(p => $6c7bd7858deea686$var$escapeRegex(p.value)));\n  let sortedLiterals = [...new Set([...allPartsLiterals, ...pluralPartsLiterals])].sort((a, b) => b.length - a.length);\n  let literals = sortedLiterals.length === 0 ? new RegExp(\"[\\\\p{White_Space}]\", \"gu\") : new RegExp(`${sortedLiterals.join(\"|\")}|[\\\\p{White_Space}]`, \"gu\");\n  // These are for replacing non-latn characters with the latn equivalent\n  let numerals = [...new Intl.NumberFormat(intlOptions.locale, {\n    useGrouping: false\n  }).format(9876543210)].reverse();\n  let indexes = new Map(numerals.map((d, i) => [d, i]));\n  let numeral = new RegExp(`[${numerals.join(\"\")}]`, \"g\");\n  let index = d => String(indexes.get(d));\n  return {\n    minusSign: minusSign,\n    plusSign: plusSign,\n    decimal: decimal,\n    group: group,\n    literals: literals,\n    numeral: numeral,\n    index: index\n  };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n  // @ts-ignore\n  if (str.replaceAll)\n    // @ts-ignore\n    return str.replaceAll(find, replace);\n  return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nexport { $6c7bd7858deea686$export$cd11ab140839f11d as NumberParser };","map":{"version":3,"names":["NumberFormatter","$488c6ddbf4ef74c2$export$cc77c4ff7e8673c5","$6c7bd7858deea686$var$CURRENCY_SIGN_REGEX","RegExp","$6c7bd7858deea686$var$NUMBERING_SYSTEMS","$6c7bd7858deea686$export$cd11ab140839f11d","parse","value","$6c7bd7858deea686$var$getNumberParserImpl","locale","options","isValidPartialNumber","minValue","maxValue","getNumberingSystem","numberingSystem","constructor","$6c7bd7858deea686$var$numberParserCache","Map","defaultParser","$6c7bd7858deea686$var$getCachedNumberParser","includes","parser","cacheKey","Object","entries","sort","a","b","join","get","$6c7bd7858deea686$var$NumberParserImpl","set","fullySanitizedValue","sanitize","symbols","group","$6c7bd7858deea686$var$replaceAll","decimal","replace","minusSign","numeral","index","style","isNegative","indexOf","length","slice","newValue","NaN","isNaN","minimumFractionDigits","Math","min","maximumFractionDigits","format","currencySign","test","literals","String","fromCharCode","Infinity","startsWith","plusSign","formatter","Intl","NumberFormat","resolvedOptions","$6c7bd7858deea686$var$getSymbols","_this_options_minimumFractionDigits","_this_options_maximumFractionDigits","console","warn","$6c7bd7858deea686$var$nonLiteralParts","Set","$6c7bd7858deea686$var$pluralNumbers","intlOptions","originalOptions","_allParts_find","_posAllParts_find","_decimalParts_find","_allParts_find1","symbolFormatter","minimumSignificantDigits","maximumSignificantDigits","allParts","formatToParts","posAllParts","pluralParts","map","n","_allParts_find_value","find","p","type","signDisplay","decimalParts","allPartsLiterals","filter","has","$6c7bd7858deea686$var$escapeRegex","pluralPartsLiterals","flatMap","sortedLiterals","numerals","useGrouping","reverse","indexes","d","i","str","replaceAll","split","string","NumberParser"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@internationalized/number/dist/NumberParser.mjs"],"sourcesContent":["import {NumberFormatter as $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5} from \"./NumberFormatter.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp(\"^.*\\\\(.*\\\\).*$\");\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [\n    \"latn\",\n    \"arab\",\n    \"hanidec\"\n];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n    /**\n   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n   */ parse(value) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n    }\n    /**\n   * Returns whether the given string could potentially be a valid number. This should be used to\n   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n   * of the minus/plus sign characters can be checked.\n   */ isValidPartialNumber(value, minValue, maxValue) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n    }\n    /**\n   * Returns a numbering system for which the given string is valid in the current locale.\n   * If no numbering system could be detected, the default numbering system for the current\n   * locale is returned.\n   */ getNumberingSystem(value) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n    }\n    constructor(locale, options = {}){\n        this.locale = locale;\n        this.options = options;\n    }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n    // First try the default numbering system for the provided locale\n    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n    // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n    // try each of the other supported numbering systems until we find one that matches.\n    if (!locale.includes(\"-nu-\") && !defaultParser.isValidPartialNumber(value)) {\n        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {\n            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes(\"-u-\") ? \"-nu-\" : \"-u-nu-\") + numberingSystem, options);\n            if (parser.isValidPartialNumber(value)) return parser;\n        }\n    }\n    return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1).join() : \"\");\n    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n    if (!parser) {\n        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n    }\n    return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n    parse(value) {\n        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n        let fullySanitizedValue = this.sanitize(value);\n        if (this.symbols.group) // Remove group characters, and replace decimal points and numerals with ASCII values.\n        fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, \"\");\n        if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, \".\");\n        if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, \"-\");\n        fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);\n        if (this.options.style === \"percent\") {\n            // javascript is bad at dividing by 100 and maintaining the same significant figures, so perform it on the string before parsing\n            let isNegative = fullySanitizedValue.indexOf(\"-\");\n            fullySanitizedValue = fullySanitizedValue.replace(\"-\", \"\");\n            let index = fullySanitizedValue.indexOf(\".\");\n            if (index === -1) index = fullySanitizedValue.length;\n            fullySanitizedValue = fullySanitizedValue.replace(\".\", \"\");\n            if (index - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;\n            else if (index - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;\n            else if (index - 2 === -2) fullySanitizedValue = \"0.00\";\n            else fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;\n            if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;\n        }\n        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n        if (isNaN(newValue)) return NaN;\n        if (this.options.style === \"percent\") {\n            // extra step for rounding percents to what our formatter would output\n            let options = {\n                ...this.options,\n                style: \"decimal\",\n                minimumFractionDigits: Math.min(this.options.minimumFractionDigits + 2, 20),\n                maximumFractionDigits: Math.min(this.options.maximumFractionDigits + 2, 20)\n            };\n            return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));\n        }\n        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n        if (this.options.currencySign === \"accounting\" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n        return newValue;\n    }\n    sanitize(value) {\n        // Remove literals and whitespace, which are allowed anywhere in the string\n        value = value.replace(this.symbols.literals, \"\");\n        // Replace the ASCII minus sign with the minus sign used in the current locale\n        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n        if (this.symbols.minusSign) value = value.replace(\"-\", this.symbols.minusSign);\n        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n        // instead they use the , (44) character or apparently the (1548) character.\n        if (this.options.numberingSystem === \"arab\") {\n            if (this.symbols.decimal) {\n                value = value.replace(\",\", this.symbols.decimal);\n                value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n            }\n            if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, \".\", this.symbols.group);\n        }\n        // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n        // so allow 'period' as a group char and replace it with a space\n        if (this.options.locale === \"fr-FR\") value = $6c7bd7858deea686$var$replaceAll(value, \".\", String.fromCharCode(8239));\n        return value;\n    }\n    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\n        value = this.sanitize(value);\n        // Remove minus or plus sign, which must be at the start of the string.\n        if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);\n        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n        // Numbers cannot start with a group separator\n        if (this.symbols.group && value.startsWith(this.symbols.group)) return false;\n        // Numbers that can't have any decimal values fail if a decimal character is typed\n        if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;\n        // Remove numerals, groups, and decimals\n        if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, \"\");\n        value = value.replace(this.symbols.numeral, \"\");\n        if (this.symbols.decimal) value = value.replace(this.symbols.decimal, \"\");\n        // The number is valid if there are no remaining characters\n        return value.length === 0;\n    }\n    constructor(locale, options = {}){\n        this.locale = locale;\n        this.formatter = new Intl.NumberFormat(locale, options);\n        this.options = this.formatter.resolvedOptions();\n        this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);\n        var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;\n        if (this.options.style === \"percent\" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn(\"NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.\");\n    }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set([\n    \"decimal\",\n    \"fraction\",\n    \"integer\",\n    \"minusSign\",\n    \"plusSign\",\n    \"group\"\n]);\n// This list is derived from https://www.unicode.org/cldr/charts/43/supplemental/language_plural_rules.html#comparison and includes\n// all unique numbers which we need to check in order to determine all the plural forms for a given locale.\n// See: https://github.com/adobe/react-spectrum/pull/5134/files#r1337037855 for used script\nconst $6c7bd7858deea686$var$pluralNumbers = [\n    0,\n    4,\n    2,\n    1,\n    11,\n    20,\n    3,\n    7,\n    100,\n    21,\n    0.1,\n    1.1\n];\nfunction $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {\n    var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;\n    // formatter needs access to all decimal places in order to generate the correct literal strings for the plural set\n    let symbolFormatter = new Intl.NumberFormat(locale, {\n        ...intlOptions,\n        minimumSignificantDigits: 1,\n        maximumSignificantDigits: 21\n    });\n    // Note: some locale's don't add a group symbol until there is a ten thousands place\n    let allParts = symbolFormatter.formatToParts(-10000.111);\n    let posAllParts = symbolFormatter.formatToParts(10000.111);\n    let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n)=>symbolFormatter.formatToParts(n));\n    var _allParts_find_value;\n    let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p)=>p.type === \"minusSign\")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : \"-\";\n    let plusSign = (_posAllParts_find = posAllParts.find((p)=>p.type === \"plusSign\")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;\n    // Safari does not support the signDisplay option, but our number parser polyfills it.\n    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n    // @ts-ignore\n    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"exceptZero\" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === \"always\")) plusSign = \"+\";\n    // If maximumSignificantDigits is 1 (the minimum) then we won't get decimal characters out of the above formatters\n    // Percent also defaults to 0 fractionDigits, so we need to make a new one that isn't percent to get an accurate decimal\n    let decimalParts = new Intl.NumberFormat(locale, {\n        ...intlOptions,\n        minimumFractionDigits: 2,\n        maximumFractionDigits: 2\n    }).formatToParts(0.001);\n    let decimal = (_decimalParts_find = decimalParts.find((p)=>p.type === \"decimal\")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;\n    let group = (_allParts_find1 = allParts.find((p)=>p.type === \"group\")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;\n    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n    // don't contribute to the numerical value\n    let allPartsLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value));\n    let pluralPartsLiterals = pluralParts.flatMap((p)=>p.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)));\n    let sortedLiterals = [\n        ...new Set([\n            ...allPartsLiterals,\n            ...pluralPartsLiterals\n        ])\n    ].sort((a, b)=>b.length - a.length);\n    let literals = sortedLiterals.length === 0 ? new RegExp(\"[\\\\p{White_Space}]\", \"gu\") : new RegExp(`${sortedLiterals.join(\"|\")}|[\\\\p{White_Space}]`, \"gu\");\n    // These are for replacing non-latn characters with the latn equivalent\n    let numerals = [\n        ...new Intl.NumberFormat(intlOptions.locale, {\n            useGrouping: false\n        }).format(9876543210)\n    ].reverse();\n    let indexes = new Map(numerals.map((d, i)=>[\n            d,\n            i\n        ]));\n    let numeral = new RegExp(`[${numerals.join(\"\")}]`, \"g\");\n    let index = (d)=>String(indexes.get(d));\n    return {\n        minusSign: minusSign,\n        plusSign: plusSign,\n        decimal: decimal,\n        group: group,\n        literals: literals,\n        numeral: numeral,\n        index: index\n    };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n    // @ts-ignore\n    if (str.replaceAll) // @ts-ignore\n    return str.replaceAll(find, replace);\n    return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\n\nexport {$6c7bd7858deea686$export$cd11ab140839f11d as NumberParser};\n//# sourceMappingURL=NumberParser.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}