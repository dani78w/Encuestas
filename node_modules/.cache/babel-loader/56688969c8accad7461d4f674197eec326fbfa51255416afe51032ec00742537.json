{"ast":null,"code":"import { Selection as $e40ea825a81a3709$export$52baac22726c72bf } from \"./Selection.mjs\";\nimport { useControlledState as $6tM1y$useControlledState } from \"@react-stately/utils\";\nimport { useRef as $6tM1y$useRef, useState as $6tM1y$useState, useMemo as $6tM1y$useMemo, useEffect as $6tM1y$useEffect } from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n  if (setA.size !== setB.size) return false;\n  for (let item of setA) {\n    if (!setB.has(item)) return false;\n  }\n  return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n  let {\n    selectionMode = \"none\",\n    disallowEmptySelection: disallowEmptySelection,\n    allowDuplicateSelectionEvents: allowDuplicateSelectionEvents,\n    selectionBehavior: selectionBehaviorProp = \"toggle\",\n    disabledBehavior = \"all\"\n  } = props;\n  // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n  // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n  let isFocusedRef = (0, $6tM1y$useRef)(false);\n  let [, setFocused] = (0, $6tM1y$useState)(false);\n  let focusedKeyRef = (0, $6tM1y$useRef)(null);\n  let childFocusStrategyRef = (0, $6tM1y$useRef)(null);\n  let [, setFocusedKey] = (0, $6tM1y$useState)(null);\n  let selectedKeysProp = (0, $6tM1y$useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [props.selectedKeys]);\n  let defaultSelectedKeys = (0, $6tM1y$useMemo)(() => $7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [props.defaultSelectedKeys]);\n  let [selectedKeys, setSelectedKeys] = (0, $6tM1y$useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n  let disabledKeysProp = (0, $6tM1y$useMemo)(() => props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [props.disabledKeys]);\n  let [selectionBehavior, setSelectionBehavior] = (0, $6tM1y$useState)(selectionBehaviorProp);\n  // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n  // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n  if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n  // If the selectionBehavior prop changes, update the state as well.\n  let lastSelectionBehavior = (0, $6tM1y$useRef)(selectionBehaviorProp);\n  (0, $6tM1y$useEffect)(() => {\n    if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n      setSelectionBehavior(selectionBehaviorProp);\n      lastSelectionBehavior.current = selectionBehaviorProp;\n    }\n  }, [selectionBehaviorProp]);\n  return {\n    selectionMode: selectionMode,\n    disallowEmptySelection: disallowEmptySelection,\n    selectionBehavior: selectionBehavior,\n    setSelectionBehavior: setSelectionBehavior,\n    get isFocused() {\n      return isFocusedRef.current;\n    },\n    setFocused(f) {\n      isFocusedRef.current = f;\n      setFocused(f);\n    },\n    get focusedKey() {\n      return focusedKeyRef.current;\n    },\n    get childFocusStrategy() {\n      return childFocusStrategyRef.current;\n    },\n    setFocusedKey(k, childFocusStrategy = \"first\") {\n      focusedKeyRef.current = k;\n      childFocusStrategyRef.current = childFocusStrategy;\n      setFocusedKey(k);\n    },\n    selectedKeys: selectedKeys,\n    setSelectedKeys(keys) {\n      if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n    },\n    disabledKeys: disabledKeysProp,\n    disabledBehavior: disabledBehavior\n  };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n  if (!selection) return defaultValue;\n  return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\nexport { $7af3f5b51489e0b5$export$253fe78d46329472 as useMultipleSelectionState };","map":{"version":3,"names":["Selection","$e40ea825a81a3709$export$52baac22726c72bf","useControlledState","$6tM1y$useControlledState","useRef","$6tM1y$useRef","useState","$6tM1y$useState","useMemo","$6tM1y$useMemo","useEffect","$6tM1y$useEffect","$7af3f5b51489e0b5$var$equalSets","setA","setB","size","item","has","$7af3f5b51489e0b5$export$253fe78d46329472","props","selectionMode","disallowEmptySelection","allowDuplicateSelectionEvents","selectionBehavior","selectionBehaviorProp","disabledBehavior","isFocusedRef","setFocused","focusedKeyRef","childFocusStrategyRef","setFocusedKey","selectedKeysProp","$7af3f5b51489e0b5$var$convertSelection","selectedKeys","defaultSelectedKeys","setSelectedKeys","onSelectionChange","disabledKeysProp","disabledKeys","Set","setSelectionBehavior","lastSelectionBehavior","current","isFocused","f","focusedKey","childFocusStrategy","k","keys","selection","defaultValue","useMultipleSelectionState"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-stately/selection/dist/useMultipleSelectionState.mjs"],"sourcesContent":["import {Selection as $e40ea825a81a3709$export$52baac22726c72bf} from \"./Selection.mjs\";\nimport {useControlledState as $6tM1y$useControlledState} from \"@react-stately/utils\";\nimport {useRef as $6tM1y$useRef, useState as $6tM1y$useState, useMemo as $6tM1y$useMemo, useEffect as $6tM1y$useEffect} from \"react\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $7af3f5b51489e0b5$var$equalSets(setA, setB) {\n    if (setA.size !== setB.size) return false;\n    for (let item of setA){\n        if (!setB.has(item)) return false;\n    }\n    return true;\n}\nfunction $7af3f5b51489e0b5$export$253fe78d46329472(props) {\n    let { selectionMode: selectionMode = \"none\", disallowEmptySelection: disallowEmptySelection, allowDuplicateSelectionEvents: allowDuplicateSelectionEvents, selectionBehavior: selectionBehaviorProp = \"toggle\", disabledBehavior: disabledBehavior = \"all\" } = props;\n    // We want synchronous updates to `isFocused` and `focusedKey` after their setters are called.\n    // But we also need to trigger a react re-render. So, we have both a ref (sync) and state (async).\n    let isFocusedRef = (0, $6tM1y$useRef)(false);\n    let [, setFocused] = (0, $6tM1y$useState)(false);\n    let focusedKeyRef = (0, $6tM1y$useRef)(null);\n    let childFocusStrategyRef = (0, $6tM1y$useRef)(null);\n    let [, setFocusedKey] = (0, $6tM1y$useState)(null);\n    let selectedKeysProp = (0, $6tM1y$useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.selectedKeys), [\n        props.selectedKeys\n    ]);\n    let defaultSelectedKeys = (0, $6tM1y$useMemo)(()=>$7af3f5b51489e0b5$var$convertSelection(props.defaultSelectedKeys, new (0, $e40ea825a81a3709$export$52baac22726c72bf)()), [\n        props.defaultSelectedKeys\n    ]);\n    let [selectedKeys, setSelectedKeys] = (0, $6tM1y$useControlledState)(selectedKeysProp, defaultSelectedKeys, props.onSelectionChange);\n    let disabledKeysProp = (0, $6tM1y$useMemo)(()=>props.disabledKeys ? new Set(props.disabledKeys) : new Set(), [\n        props.disabledKeys\n    ]);\n    let [selectionBehavior, setSelectionBehavior] = (0, $6tM1y$useState)(selectionBehaviorProp);\n    // If the selectionBehavior prop is set to replace, but the current state is toggle (e.g. due to long press\n    // to enter selection mode on touch), and the selection becomes empty, reset the selection behavior.\n    if (selectionBehaviorProp === \"replace\" && selectionBehavior === \"toggle\" && typeof selectedKeys === \"object\" && selectedKeys.size === 0) setSelectionBehavior(\"replace\");\n    // If the selectionBehavior prop changes, update the state as well.\n    let lastSelectionBehavior = (0, $6tM1y$useRef)(selectionBehaviorProp);\n    (0, $6tM1y$useEffect)(()=>{\n        if (selectionBehaviorProp !== lastSelectionBehavior.current) {\n            setSelectionBehavior(selectionBehaviorProp);\n            lastSelectionBehavior.current = selectionBehaviorProp;\n        }\n    }, [\n        selectionBehaviorProp\n    ]);\n    return {\n        selectionMode: selectionMode,\n        disallowEmptySelection: disallowEmptySelection,\n        selectionBehavior: selectionBehavior,\n        setSelectionBehavior: setSelectionBehavior,\n        get isFocused () {\n            return isFocusedRef.current;\n        },\n        setFocused (f) {\n            isFocusedRef.current = f;\n            setFocused(f);\n        },\n        get focusedKey () {\n            return focusedKeyRef.current;\n        },\n        get childFocusStrategy () {\n            return childFocusStrategyRef.current;\n        },\n        setFocusedKey (k, childFocusStrategy = \"first\") {\n            focusedKeyRef.current = k;\n            childFocusStrategyRef.current = childFocusStrategy;\n            setFocusedKey(k);\n        },\n        selectedKeys: selectedKeys,\n        setSelectedKeys (keys) {\n            if (allowDuplicateSelectionEvents || !$7af3f5b51489e0b5$var$equalSets(keys, selectedKeys)) setSelectedKeys(keys);\n        },\n        disabledKeys: disabledKeysProp,\n        disabledBehavior: disabledBehavior\n    };\n}\nfunction $7af3f5b51489e0b5$var$convertSelection(selection, defaultValue) {\n    if (!selection) return defaultValue;\n    return selection === \"all\" ? \"all\" : new (0, $e40ea825a81a3709$export$52baac22726c72bf)(selection);\n}\n\n\nexport {$7af3f5b51489e0b5$export$253fe78d46329472 as useMultipleSelectionState};\n//# sourceMappingURL=useMultipleSelectionState.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}