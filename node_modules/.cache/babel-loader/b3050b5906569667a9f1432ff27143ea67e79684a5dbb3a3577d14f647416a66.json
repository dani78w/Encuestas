{"ast":null,"code":"import { useTextField as $2d73ec29415bd339$export$712718f7aec83d5 } from \"./useTextField.mjs\";\nimport { useEffectEvent as $jyGKS$useEffectEvent, mergeProps as $jyGKS$mergeProps } from \"@react-aria/utils\";\nimport { useEffect as $jyGKS$useEffect, useRef as $jyGKS$useRef } from \"react\";\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {\n  return typeof window !== \"undefined\" && window.InputEvent &&\n  // @ts-ignore\n  typeof InputEvent.prototype.getTargetRanges === \"function\";\n}\nfunction $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {\n  // All browsers implement the 'beforeinput' event natively except Firefox\n  // (currently behind a flag as of Firefox 84). React's polyfill does not\n  // run in all cases that the native event fires, e.g. when deleting text.\n  // Use the native event if available so that we can prevent invalid deletions.\n  // We do not attempt to polyfill this in Firefox since it would be very complicated,\n  // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n  let onBeforeInputFallback = (0, $jyGKS$useEffectEvent)(e => {\n    let input = inputRef.current;\n    // Compute the next value of the input if the event is allowed to proceed.\n    // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n    let nextValue;\n    switch (e.inputType) {\n      case \"historyUndo\":\n      case \"historyRedo\":\n        // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n        // because presumably the input would have already been validated previously.\n        return;\n      case \"insertLineBreak\":\n        // Explicitly allow \"insertLineBreak\" event, to allow onSubmit for \"enter\" key. e.data is null in this case.\n        return;\n      case \"deleteContent\":\n      case \"deleteByCut\":\n      case \"deleteByDrag\":\n        nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case \"deleteContentForward\":\n        // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n        // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n        // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n        // If we support additional locales in the future, this may need to change.\n        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case \"deleteContentBackward\":\n        nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n        break;\n      case \"deleteSoftLineBackward\":\n      case \"deleteHardLineBackward\":\n        nextValue = input.value.slice(input.selectionStart);\n        break;\n      default:\n        if (e.data != null) nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n        break;\n    }\n    // If we did not compute a value, or the new value is invalid, prevent the event\n    // so that the browser does not update the input text, move the selection, or add to\n    // the undo/redo stack.\n    if (nextValue == null || !state.validate(nextValue)) e.preventDefault();\n  });\n  (0, $jyGKS$useEffect)(() => {\n    if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent()) return;\n    let input = inputRef.current;\n    input.addEventListener(\"beforeinput\", onBeforeInputFallback, false);\n    return () => {\n      input.removeEventListener(\"beforeinput\", onBeforeInputFallback, false);\n    };\n  }, [inputRef, onBeforeInputFallback]);\n  let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? e => {\n    let nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n    if (!state.validate(nextValue)) e.preventDefault();\n  } : null;\n  let {\n    labelProps: labelProps,\n    inputProps: textFieldProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps,\n    ...validation\n  } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);\n  let compositionStartState = (0, $jyGKS$useRef)(null);\n  return {\n    inputProps: (0, $jyGKS$mergeProps)(textFieldProps, {\n      onBeforeInput: onBeforeInput,\n      onCompositionStart() {\n        // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n        // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n        // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n        // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n        // nor would we want to cancel them because the input from the user is incomplete at that point.\n        // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n        // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n        // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n        // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n        // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n        // are implemented, there is no other way to prevent composed input.\n        // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n        let {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        } = inputRef.current;\n        compositionStartState.current = {\n          value: value,\n          selectionStart: selectionStart,\n          selectionEnd: selectionEnd\n        };\n      },\n      onCompositionEnd() {\n        if (!state.validate(inputRef.current.value)) {\n          // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n          // But also update the value in React state as well so it is correct for future updates.\n          let {\n            value: value,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd\n          } = compositionStartState.current;\n          inputRef.current.value = value;\n          inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n          state.setInputValue(value);\n        }\n      }\n    }),\n    labelProps: labelProps,\n    descriptionProps: descriptionProps,\n    errorMessageProps: errorMessageProps,\n    ...validation\n  };\n}\nexport { $d841c8010a73d545$export$4f384c9210e583c3 as useFormattedTextField };","map":{"version":3,"names":["useTextField","$2d73ec29415bd339$export$712718f7aec83d5","useEffectEvent","$jyGKS$useEffectEvent","mergeProps","$jyGKS$mergeProps","useEffect","$jyGKS$useEffect","useRef","$jyGKS$useRef","$d841c8010a73d545$var$supportsNativeBeforeInputEvent","window","InputEvent","prototype","getTargetRanges","$d841c8010a73d545$export$4f384c9210e583c3","props","state","inputRef","onBeforeInputFallback","e","input","current","nextValue","inputType","value","slice","selectionStart","selectionEnd","data","validate","preventDefault","addEventListener","removeEventListener","onBeforeInput","target","labelProps","inputProps","textFieldProps","descriptionProps","errorMessageProps","validation","compositionStartState","onCompositionStart","onCompositionEnd","setSelectionRange","setInputValue","useFormattedTextField"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-aria/textfield/dist/useFormattedTextField.mjs"],"sourcesContent":["import {useTextField as $2d73ec29415bd339$export$712718f7aec83d5} from \"./useTextField.mjs\";\nimport {useEffectEvent as $jyGKS$useEffectEvent, mergeProps as $jyGKS$mergeProps} from \"@react-aria/utils\";\nimport {useEffect as $jyGKS$useEffect, useRef as $jyGKS$useRef} from \"react\";\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\nfunction $d841c8010a73d545$var$supportsNativeBeforeInputEvent() {\n    return typeof window !== \"undefined\" && window.InputEvent && // @ts-ignore\n    typeof InputEvent.prototype.getTargetRanges === \"function\";\n}\nfunction $d841c8010a73d545$export$4f384c9210e583c3(props, state, inputRef) {\n    // All browsers implement the 'beforeinput' event natively except Firefox\n    // (currently behind a flag as of Firefox 84). React's polyfill does not\n    // run in all cases that the native event fires, e.g. when deleting text.\n    // Use the native event if available so that we can prevent invalid deletions.\n    // We do not attempt to polyfill this in Firefox since it would be very complicated,\n    // the benefit of doing so is fairly minor, and it's going to be natively supported soon.\n    let onBeforeInputFallback = (0, $jyGKS$useEffectEvent)((e)=>{\n        let input = inputRef.current;\n        // Compute the next value of the input if the event is allowed to proceed.\n        // See https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes for a full list of input types.\n        let nextValue;\n        switch(e.inputType){\n            case \"historyUndo\":\n            case \"historyRedo\":\n                // Explicitly allow undo/redo. e.data is null in this case, but there's no need to validate,\n                // because presumably the input would have already been validated previously.\n                return;\n            case \"insertLineBreak\":\n                // Explicitly allow \"insertLineBreak\" event, to allow onSubmit for \"enter\" key. e.data is null in this case.\n                return;\n            case \"deleteContent\":\n            case \"deleteByCut\":\n            case \"deleteByDrag\":\n                nextValue = input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n                break;\n            case \"deleteContentForward\":\n                // This is potentially incorrect, since the browser may actually delete more than a single UTF-16\n                // character. In reality, a full Unicode grapheme cluster consisting of multiple UTF-16 characters\n                // or code points may be deleted. However, in our currently supported locales, there are no such cases.\n                // If we support additional locales in the future, this may need to change.\n                nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd + 1) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n                break;\n            case \"deleteContentBackward\":\n                nextValue = input.selectionEnd === input.selectionStart ? input.value.slice(0, input.selectionStart - 1) + input.value.slice(input.selectionStart) : input.value.slice(0, input.selectionStart) + input.value.slice(input.selectionEnd);\n                break;\n            case \"deleteSoftLineBackward\":\n            case \"deleteHardLineBackward\":\n                nextValue = input.value.slice(input.selectionStart);\n                break;\n            default:\n                if (e.data != null) nextValue = input.value.slice(0, input.selectionStart) + e.data + input.value.slice(input.selectionEnd);\n                break;\n        }\n        // If we did not compute a value, or the new value is invalid, prevent the event\n        // so that the browser does not update the input text, move the selection, or add to\n        // the undo/redo stack.\n        if (nextValue == null || !state.validate(nextValue)) e.preventDefault();\n    });\n    (0, $jyGKS$useEffect)(()=>{\n        if (!$d841c8010a73d545$var$supportsNativeBeforeInputEvent()) return;\n        let input = inputRef.current;\n        input.addEventListener(\"beforeinput\", onBeforeInputFallback, false);\n        return ()=>{\n            input.removeEventListener(\"beforeinput\", onBeforeInputFallback, false);\n        };\n    }, [\n        inputRef,\n        onBeforeInputFallback\n    ]);\n    let onBeforeInput = !$d841c8010a73d545$var$supportsNativeBeforeInputEvent() ? (e)=>{\n        let nextValue = e.target.value.slice(0, e.target.selectionStart) + e.data + e.target.value.slice(e.target.selectionEnd);\n        if (!state.validate(nextValue)) e.preventDefault();\n    } : null;\n    let { labelProps: labelProps, inputProps: textFieldProps, descriptionProps: descriptionProps, errorMessageProps: errorMessageProps, ...validation } = (0, $2d73ec29415bd339$export$712718f7aec83d5)(props, inputRef);\n    let compositionStartState = (0, $jyGKS$useRef)(null);\n    return {\n        inputProps: (0, $jyGKS$mergeProps)(textFieldProps, {\n            onBeforeInput: onBeforeInput,\n            onCompositionStart () {\n                // Chrome does not implement Input Events Level 2, which specifies the insertFromComposition\n                // and deleteByComposition inputType values for the beforeinput event. These are meant to occur\n                // at the end of a composition (e.g. Pinyin IME, Android auto correct, etc.), and crucially, are\n                // cancelable. The insertCompositionText and deleteCompositionText input types are not cancelable,\n                // nor would we want to cancel them because the input from the user is incomplete at that point.\n                // In Safari, insertFromComposition/deleteFromComposition will fire, however, allowing us to cancel\n                // the final composition result if it is invalid. As a fallback for Chrome and Firefox, which either\n                // don't support Input Events Level 2, or beforeinput at all, we store the state of the input when\n                // the compositionstart event fires, and undo the changes in compositionend (below) if it is invalid.\n                // Unfortunately, this messes up the undo/redo stack, but until insertFromComposition/deleteByComposition\n                // are implemented, there is no other way to prevent composed input.\n                // See https://bugs.chromium.org/p/chromium/issues/detail?id=1022204\n                let { value: value, selectionStart: selectionStart, selectionEnd: selectionEnd } = inputRef.current;\n                compositionStartState.current = {\n                    value: value,\n                    selectionStart: selectionStart,\n                    selectionEnd: selectionEnd\n                };\n            },\n            onCompositionEnd () {\n                if (!state.validate(inputRef.current.value)) {\n                    // Restore the input value in the DOM immediately so we can synchronously update the selection position.\n                    // But also update the value in React state as well so it is correct for future updates.\n                    let { value: value, selectionStart: selectionStart, selectionEnd: selectionEnd } = compositionStartState.current;\n                    inputRef.current.value = value;\n                    inputRef.current.setSelectionRange(selectionStart, selectionEnd);\n                    state.setInputValue(value);\n                }\n            }\n        }),\n        labelProps: labelProps,\n        descriptionProps: descriptionProps,\n        errorMessageProps: errorMessageProps,\n        ...validation\n    };\n}\n\n\nexport {$d841c8010a73d545$export$4f384c9210e583c3 as useFormattedTextField};\n//# sourceMappingURL=useFormattedTextField.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}