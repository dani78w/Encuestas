{"ast":null,"code":"import { easeOut as $3eb131dcf37ad5f8$export$57636bb43b1ccbb0, tween as $3eb131dcf37ad5f8$export$dc0b63720788090c } from \"./tween.mjs\";\nimport { concatIterators as $fc36f9a046a9ce79$export$cfc14088dfefce5f, difference as $fc36f9a046a9ce79$export$acaf96a27438246b, isSetEqual as $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64 } from \"./utils.mjs\";\nimport { OverscanManager as $364191b3decf3697$export$4455ee6afb38dcbb } from \"./OverscanManager.mjs\";\nimport { Point as $3041db3296945e6e$export$baf26146a414f24a } from \"./Point.mjs\";\nimport { Rect as $60423f92c7f9ad87$export$c79fc6492f3af13d } from \"./Rect.mjs\";\nimport { ReusableView as $ad1d98aa8f0c31b4$export$1a5223887c560441 } from \"./ReusableView.mjs\";\nimport { Size as $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec } from \"./Size.mjs\";\nimport { Transaction as $8e135e531d8dcb66$export$febc5573c75cefb0 } from \"./Transaction.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n  _setContentSize(size) {\n    this._contentSize = size;\n    this.delegate.setContentSize(size);\n  }\n  _setContentOffset(offset) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n    this.delegate.setVisibleRect(rect);\n  }\n  /**\n  * Get the size of the scrollable content.\n  */\n  get contentSize() {\n    return this._contentSize;\n  }\n  /**\n  * Get the collection view's currently visible rectangle.\n  */\n  get visibleRect() {\n    return this._visibleRect;\n  }\n  /**\n  * Set the collection view's currently visible rectangle.\n  */\n  set visibleRect(rect) {\n    this._setVisibleRect(rect);\n  }\n  _setVisibleRect(rect, forceUpdate = false) {\n    let current = this._visibleRect;\n    // Ignore if the rects are equal\n    if (rect.equals(current)) return;\n    if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n    let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n    this._resetAnimatedContentOffset();\n    this._visibleRect = rect;\n    if (shouldInvalidate)\n      // We are already in a layout effect when this method is called, so relayoutNow is appropriate.\n      this.relayoutNow({\n        offsetChanged: !rect.pointEquals(current),\n        sizeChanged: !rect.sizeEquals(current)\n      });else this.updateSubviews(forceUpdate);\n  }\n  get collection() {\n    return this._collection;\n  }\n  set collection(data) {\n    this._setData(data);\n  }\n  _setData(data) {\n    if (data === this._collection) return;\n    if (this._collection) this._runTransaction(() => {\n      this._collection = data;\n    }, this.transitionDuration > 0);else {\n      this._collection = data;\n      this.reloadData();\n    }\n  }\n  /**\n  * Reloads the data from the data source and relayouts the collection view.\n  * Does not animate any changes. Equivalent to re-assigning the same data source\n  * to the collection view.\n  */\n  reloadData() {\n    this.relayout({\n      contentChanged: true\n    });\n  }\n  /**\n  * Returns the item with the given key.\n  */\n  getItem(key) {\n    return this._collection ? this._collection.getItem(key) : null;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  get persistedKeys() {\n    return this._persistedKeys;\n  }\n  /** The set of persisted keys are always present in the DOM, even if not currently in view. */\n  set persistedKeys(persistedKeys) {\n    if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n      this._persistedKeys = persistedKeys;\n      this.updateSubviews();\n    }\n  }\n  /** Returns whether the given key, or an ancestor, is persisted. */\n  isPersistedKey(key) {\n    // Quick check if the key is directly in the set of persisted keys.\n    if (this._persistedKeys.has(key)) return true;\n    // If not, check if the key is an ancestor of any of the persisted keys.\n    for (let k of this._persistedKeys) while (k != null) {\n      let layoutInfo = this.layout.getLayoutInfo(k);\n      if (!layoutInfo) break;\n      k = layoutInfo.parentKey;\n      if (k === key) return true;\n    }\n    return false;\n  }\n  /**\n  * Get the collection view's layout.\n  */\n  get layout() {\n    return this._layout;\n  }\n  /**\n  * Set the collection view's layout.\n  */\n  set layout(layout) {\n    this.setLayout(layout);\n  }\n  /**\n  * Sets the collection view's layout, optionally with an animated transition\n  * from the current layout to the new layout.\n  * @param layout The layout to switch to.\n  * @param animated Whether to animate the layout change.\n  */\n  setLayout(layout, animated = false) {\n    if (layout === this._layout) return;\n    let applyLayout = () => {\n      if (this._layout)\n        // @ts-ignore\n        this._layout.virtualizer = null;\n      layout.virtualizer = this;\n      this._layout = layout;\n    };\n    if (animated)\n      // Animated layout transitions are really simple, thanks to our transaction support.\n      // We just set the layout inside a transaction action, which runs after the initial\n      // layout infos for the animation are retrieved from the previous layout. Then, the\n      // final layout infos are retrieved from the new layout, and animations occur.\n      this._runTransaction(applyLayout);else {\n      applyLayout();\n      this.relayout();\n    }\n  }\n  _getReuseType(layoutInfo, content) {\n    if (layoutInfo.type === \"item\" && content) {\n      let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n      let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n      return {\n        type: type,\n        reuseType: reuseType\n      };\n    }\n    return {\n      type: layoutInfo.type,\n      reuseType: layoutInfo.type\n    };\n  }\n  getReusableView(layoutInfo) {\n    let content = this.getItem(layoutInfo.key);\n    let {\n      reuseType: reuseType\n    } = this._getReuseType(layoutInfo, content);\n    if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n    let reusable = this._reusableViews[reuseType];\n    let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n    view.viewType = reuseType;\n    if (!this._animatedContentOffset.isOrigin()) {\n      layoutInfo = layoutInfo.copy();\n      layoutInfo.rect.x += this._animatedContentOffset.x;\n      layoutInfo.rect.y += this._animatedContentOffset.y;\n    }\n    view.layoutInfo = layoutInfo;\n    this._renderView(view);\n    return view;\n  }\n  _renderView(reusableView) {\n    let {\n      type: type,\n      key: key\n    } = reusableView.layoutInfo;\n    reusableView.content = this.getItem(key);\n    reusableView.rendered = this._renderContent(type, reusableView.content);\n  }\n  _renderContent(type, content) {\n    let cached = this._renderedContent.get(content);\n    if (cached != null) return cached;\n    let rendered = this.delegate.renderView(type, content);\n    if (content) this._renderedContent.set(content, rendered);\n    return rendered;\n  }\n  /**\n  * Returns an array of all currently visible views, including both\n  * item views and supplementary views.\n  */\n  get visibleViews() {\n    return Array.from(this._visibleViews.values());\n  }\n  /**\n  * Gets the visible view for the given type and key. Returns null if\n  * the view is not currently visible.\n  *\n  * @param key The key of the view to retrieve.\n  */\n  getView(key) {\n    return this._visibleViews.get(key) || null;\n  }\n  /**\n  * Returns an array of visible views matching the given type.\n  * @param type The view type to find.\n  */\n  getViewsOfType(type) {\n    return this.visibleViews.filter(v => v.layoutInfo && v.layoutInfo.type === type);\n  }\n  /**\n  * Returns the key for the given view. Returns null\n  * if the view is not currently visible.\n  */\n  keyForView(view) {\n    if (view && view.layoutInfo) return view.layoutInfo.key;\n    return null;\n  }\n  /**\n  * Returns the key for the item view currently at the given point.\n  */\n  keyAtPoint(point) {\n    let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    // Layout may return multiple layout infos in the case of\n    // persisted keys, so find the first one that actually intersects.\n    for (let layoutInfo of layoutInfos) {\n      if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n    }\n    return null;\n  }\n  /**\n  * Cleanup for when the Virtualizer will be unmounted.\n  */\n  willUnmount() {\n    cancelAnimationFrame(this._relayoutRaf);\n  }\n  /**\n  * Triggers a layout invalidation, and updates the visible subviews.\n  */\n  relayout(context = {}) {\n    // Ignore relayouts while animating the scroll position\n    if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n    // If we already scheduled a relayout, extend the invalidation\n    // context so we coalesce multiple relayouts in the same frame.\n    if (this._invalidationContext) {\n      Object.assign(this._invalidationContext, context);\n      return;\n    }\n    this._invalidationContext = context;\n  }\n  /**\n  * Performs a relayout immediately. Prefer {@link relayout} over this method\n  * where possible, since it coalesces multiple layout passes in the same tick.\n  */\n  relayoutNow(context = this._invalidationContext || {}) {\n    // Cancel the scheduled relayout, since we're doing it now.\n    if (this._relayoutRaf) {\n      cancelAnimationFrame(this._relayoutRaf);\n      this._relayoutRaf = null;\n      // Update the provided context with the current invalidationContext since we are cancelling\n      // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n      context = {\n        ...this._invalidationContext,\n        ...context\n      };\n    }\n    // Reset the invalidation context\n    this._invalidationContext = null;\n    // Do nothing if we don't have a layout or content, or we are\n    // in the middle of an animated scroll transition.\n    if (!this.layout || !this._collection || this._scrollAnimation) return;\n    let scrollAnchor = this._getScrollAnchor();\n    // Trigger the beforeLayout hook, if provided\n    if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n    // Validate the layout\n    this.layout.validate(context);\n    this._setContentSize(this.layout.getContentSize());\n    // Trigger the afterLayout hook, if provided\n    if (typeof context.afterLayout === \"function\") context.afterLayout();\n    // Adjust scroll position based on scroll anchor, and constrain.\n    // If the content changed, scroll to the top.\n    let visibleRect = this.getVisibleRect();\n    let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n    let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n    let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n    contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n    contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n    let hasLayoutUpdates = false;\n    if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n      // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n      // Save the difference between the current and new content offsets, and apply it to the\n      // individual content items instead. At the end of the animation, we'll reset and set the\n      // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n      // the scroll animation and the content animation.\n      if (context.animated || !this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n        this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n        hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n      } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n    } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n    // Apply layout infos, unless this is coming from an animated transaction\n    if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n    // Wait for animations, and apply the afterAnimation hook, if provided\n    if (context.animated && hasLayoutUpdates) {\n      this._enableTransitions();\n      let done = () => {\n        this._disableTransitions();\n        // Reset scroll position after animations (see above comment).\n        if (!this._animatedContentOffset.isOrigin()) {\n          // Get the content offset to scroll to, taking _animatedContentOffset into account.\n          let {\n            x: x,\n            y: y\n          } = this.getVisibleRect();\n          this._resetAnimatedContentOffset();\n          this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n        }\n        if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n      };\n      // Sometimes the animation takes slightly longer than expected.\n      setTimeout(done, this.transitionDuration + 100);\n      return;\n    } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n  }\n  /**\n  * Corrects DOM order of visible views to match item order of collection.\n  */\n  _correctItemOrder() {\n    // Defer until after scrolling and animated transactions are complete\n    if (this._isScrolling || this._transaction) return;\n    for (let key of this._visibleLayoutInfos.keys()) {\n      let view = this._visibleViews.get(key);\n      this._children.delete(view);\n      this._children.add(view);\n    }\n  }\n  _enableTransitions() {\n    this.delegate.beginAnimations();\n  }\n  _disableTransitions() {\n    this.delegate.endAnimations();\n  }\n  _getScrollAnchor() {\n    if (!this.anchorScrollPosition) return null;\n    let visibleRect = this.getVisibleRect();\n    // Ask the delegate to provide a scroll anchor, if possible\n    if (this.delegate.getScrollAnchor) {\n      let key = this.delegate.getScrollAnchor(visibleRect);\n      if (key != null) {\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let key = layoutInfo.key;\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          return {\n            key: key,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    }\n    // No need to anchor the scroll position if it is at the top\n    if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n    // Find a view with a visible corner that has the smallest distance to the top of the collection view\n    let cornerAnchor = null;\n    for (let [key, view] of this._visibleViews) {\n      let layoutInfo = view.layoutInfo;\n      if (layoutInfo && layoutInfo.rect.area > 0) {\n        let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n        if (corner) {\n          let offset = layoutInfo.rect[corner].y - visibleRect.y;\n          if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n            key: key,\n            layoutInfo: layoutInfo,\n            corner: corner,\n            offset: offset\n          };\n        }\n      }\n    }\n    return cornerAnchor;\n  }\n  _restoreScrollAnchor(scrollAnchor, context) {\n    let contentOffset = this.getVisibleRect();\n    if (scrollAnchor) {\n      var _context_transaction;\n      let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n      if (finalAnchor) {\n        let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n        contentOffset.y += adjustment;\n      }\n    }\n    return contentOffset;\n  }\n  getVisibleRect() {\n    let v = this.visibleRect;\n    let x = v.x - this._animatedContentOffset.x;\n    let y = v.y - this._animatedContentOffset.y;\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n  }\n  getVisibleLayoutInfos() {\n    let isTestEnv = false;\n    let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes(\"clientWidth\");\n    let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes(\"clientHeight\");\n    let rect;\n    if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) rect = this._getContentRect();else rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n    this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n    return this._visibleLayoutInfos;\n  }\n  _getLayoutInfoMap(rect, copy = false) {\n    let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n    let map = new Map();\n    for (let layoutInfo of layoutInfos) {\n      if (copy) layoutInfo = layoutInfo.copy();\n      map.set(layoutInfo.key, layoutInfo);\n    }\n    return map;\n  }\n  updateSubviews(forceUpdate = false) {\n    if (!this._collection) return;\n    let visibleLayoutInfos = this.getVisibleLayoutInfos();\n    let currentlyVisible = this._visibleViews;\n    let toAdd, toRemove, toUpdate;\n    // If this is a force update, remove and re-add all views.\n    // Otherwise, find and update the diff.\n    if (forceUpdate) {\n      toAdd = visibleLayoutInfos;\n      toRemove = currentlyVisible;\n      toUpdate = new Set();\n    } else {\n      ({\n        toAdd: toAdd,\n        toRemove: toRemove,\n        toUpdate: toUpdate\n      } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n      for (let key of toUpdate) {\n        let view = currentlyVisible.get(key);\n        if (!view || !view.layoutInfo) continue;\n        let item = this.getItem(visibleLayoutInfos.get(key).key);\n        if (view.content === item) toUpdate.delete(key);else {\n          // If the view type changes, delete and recreate the view instead of updating\n          let {\n            reuseType: reuseType\n          } = this._getReuseType(view.layoutInfo, item);\n          if (view.viewType !== reuseType) {\n            toUpdate.delete(key);\n            toAdd.add(key);\n            toRemove.add(key);\n          }\n        }\n      }\n      // We are done if the sets are equal\n      if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n        if (this._transaction) this._applyLayoutInfos();\n        return;\n      }\n    }\n    // Track views that should be removed. They are not removed from\n    // the DOM immediately, since we may reuse and need to re-insert\n    // them back into the DOM anyway.\n    let removed = new Set();\n    for (let key of toRemove.keys()) {\n      let view = this._visibleViews.get(key);\n      if (view) {\n        removed.add(view);\n        this._visibleViews.delete(key);\n        // If we are in the middle of a transaction, wait until the end\n        // of the animations to remove the views from the DOM. Also means\n        // we can't reuse those views immediately.\n        if (this._transaction) this._transaction.toRemove.set(key, view);else this.reuseView(view);\n      }\n    }\n    for (let key of toAdd.keys()) {\n      let layoutInfo = visibleLayoutInfos.get(key);\n      let view;\n      // If we're in a transaction, and a layout change happens\n      // during the animations such that a view that was going\n      // to be removed is now not, we don't create a new view\n      // since the old one is still in the DOM, marked as toRemove.\n      if (this._transaction) {\n        // if transaction, get initial layout attributes for the animation\n        if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n        view = this._transaction.toRemove.get(key);\n        if (view) {\n          this._transaction.toRemove.delete(key);\n          this._applyLayoutInfo(view, layoutInfo);\n        }\n      }\n      if (!view) {\n        // Create or reuse a view for this row\n        view = this.getReusableView(layoutInfo);\n        // Add the view to the DOM if needed\n        if (!removed.has(view)) this._children.add(view);\n      }\n      this._visibleViews.set(key, view);\n      removed.delete(view);\n    }\n    for (let key of toUpdate) {\n      let view = currentlyVisible.get(key);\n      this._renderedContent.delete(key);\n      this._renderView(view);\n    }\n    // Remove the remaining rows to delete from the DOM\n    if (!this._transaction) this.removeViews(removed);\n    this._correctItemOrder();\n    this._flushVisibleViews();\n    let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n    if (hasLayoutUpdates) requestAnimationFrame(() => {\n      // If we're in a transaction, apply animations to visible views\n      // and \"to be removed\" views, which animate off screen.\n      if (this._transaction) requestAnimationFrame(() => this._applyLayoutInfos());\n    });\n    return hasLayoutUpdates;\n  }\n  afterRender() {\n    if (this._transactionQueue.length > 0) this._processTransactionQueue();else if (this._invalidationContext) this.relayoutNow();\n    if (this.shouldOverscan) this._overscanManager.collectMetrics();\n  }\n  _flushVisibleViews() {\n    // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent hierarchy\n    // by referencing a parentKey. Just before rendering the visible views, we rebuild this hierarchy\n    // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n    // method to build the final tree.\n    let viewsByParentKey = new Map([[null, []]]);\n    for (let view of this._children) {\n      var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n      if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n      (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n      if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n    }\n    let buildTree = (parent, views) => views.map(view => {\n      let children = viewsByParentKey.get(view.layoutInfo.key);\n      return this.delegate.renderWrapper(parent, view, children, childViews => buildTree(view, childViews));\n    });\n    let children = buildTree(null, viewsByParentKey.get(null));\n    this.delegate.setVisibleViews(children);\n  }\n  _applyLayoutInfo(view, layoutInfo) {\n    if (view.layoutInfo === layoutInfo) return false;\n    view.layoutInfo = layoutInfo;\n    return true;\n  }\n  _applyLayoutInfos() {\n    let updated = false;\n    // Apply layout infos to visible views\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n        let layoutInfo = this.layout.getLayoutInfo(cur.key);\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n    }\n    // Apply final layout infos for views that will be removed\n    if (this._transaction) {\n      for (let view of this._transaction.toRemove.values()) {\n        let cur = view.layoutInfo;\n        if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n          let layoutInfo = this.layout.getLayoutInfo(cur.key);\n          if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n        }\n      }\n      for (let view of this._transaction.removed.values()) {\n        let cur = view.layoutInfo;\n        let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n        layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n        if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n      }\n    }\n    if (updated) this._flushVisibleViews();\n  }\n  _hasLayoutUpdates() {\n    if (!this._transaction) return false;\n    for (let view of this._visibleViews.values()) {\n      let cur = view.layoutInfo;\n      if (!cur) return true;\n      let layoutInfo = this.layout.getLayoutInfo(cur.key);\n      if (\n      // Uses equals rather than pointEquals so that width/height changes are taken into account\n      !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n    }\n    return false;\n  }\n  reuseView(view) {\n    view.prepareForReuse();\n    this._reusableViews[view.viewType].push(view);\n  }\n  removeViews(toRemove) {\n    for (let view of toRemove) this._children.delete(view);\n  }\n  updateItemSize(key, size) {\n    // TODO: we should be able to invalidate a single index path\n    // @ts-ignore\n    if (!this.layout.updateItemSize) return;\n    // If the scroll position is currently animating, add the update\n    // to a queue to be processed after the animation is complete.\n    if (this._scrollAnimation) {\n      this._sizeUpdateQueue.set(key, size);\n      return;\n    }\n    // @ts-ignore\n    let changed = this.layout.updateItemSize(key, size);\n    if (changed) this.relayout();\n  }\n  startScrolling() {\n    this._isScrolling = true;\n  }\n  endScrolling() {\n    this._isScrolling = false;\n    this._correctItemOrder();\n    this._flushVisibleViews();\n  }\n  _resetAnimatedContentOffset() {\n    // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n    if (!this._animatedContentOffset.isOrigin()) {\n      this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n      this._applyLayoutInfos();\n    }\n  }\n  /**\n  * Scrolls the item with the given key into view, optionally with an animation.\n  * @param key The key of the item to scroll into view.\n  * @param duration The duration of the scroll animation.\n  */\n  scrollToItem(key, options) {\n    // key can be 0, so check if null or undefined\n    if (key == null) return;\n    let layoutInfo = this.layout.getLayoutInfo(key);\n    if (!layoutInfo) return;\n    let {\n      duration = 300,\n      shouldScrollX = true,\n      shouldScrollY = true,\n      offsetX = 0,\n      offsetY = 0\n    } = options;\n    let x = this.visibleRect.x;\n    let y = this.visibleRect.y;\n    let minX = layoutInfo.rect.x - offsetX;\n    let minY = layoutInfo.rect.y - offsetY;\n    let maxX = x + this.visibleRect.width;\n    let maxY = y + this.visibleRect.height;\n    if (shouldScrollX) {\n      if (minX <= x || maxX === 0) x = minX;else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n    }\n    if (shouldScrollY) {\n      if (minY <= y || maxY === 0) y = minY;else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n    }\n    return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n  }\n  /**\n  * Performs an animated scroll to the given offset.\n  * @param offset - The offset to scroll to.\n  * @param duration The duration of the animation.\n  * @returns A promise that resolves when the animation is complete.\n  */\n  scrollTo(offset, duration = 300) {\n    // Cancel the current scroll animation\n    if (this._scrollAnimation) {\n      this._scrollAnimation.cancel();\n      this._scrollAnimation = null;\n    }\n    // Set the content offset synchronously if the duration is zero\n    if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n      this._setContentOffset(offset);\n      return Promise.resolve();\n    }\n    this.startScrolling();\n    this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), offset => {\n      this._setContentOffset(offset);\n    });\n    this._scrollAnimation.then(() => {\n      this._scrollAnimation = null;\n      // Process view size updates that occurred during the animation.\n      // Only views that are still visible will be actually updated.\n      for (let [key, size] of this._sizeUpdateQueue) this.updateItemSize(key, size);\n      this._sizeUpdateQueue.clear();\n      this.relayout();\n      this._processTransactionQueue();\n      this.endScrolling();\n    });\n    return this._scrollAnimation;\n  }\n  _runTransaction(action, animated) {\n    this._startTransaction();\n    if (this._nextTransaction) this._nextTransaction.actions.push(action);\n    this._endTransaction(animated);\n  }\n  _startTransaction() {\n    if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0)();\n    this._nextTransaction.level++;\n  }\n  _endTransaction(animated) {\n    if (!this._nextTransaction) return false;\n    // Save whether the transaction should be animated.\n    if (animated != null) this._nextTransaction.animated = animated;\n    // If we haven't reached level 0, we are still in a\n    // nested transaction. Wait for the parent to end.\n    if (--this._nextTransaction.level > 0) return false;\n    // Do nothing for empty transactions\n    if (this._nextTransaction.actions.length === 0) {\n      this._nextTransaction = null;\n      return false;\n    }\n    // Default animations to true\n    if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n    // Enqueue the transaction\n    this._transactionQueue.push(this._nextTransaction);\n    this._nextTransaction = null;\n    return true;\n  }\n  _processTransactionQueue() {\n    // If the current transaction is animating, wait until the end\n    // to process the next transaction.\n    if (this._transaction || this._scrollAnimation) return;\n    let next = this._transactionQueue.shift();\n    if (next) this._performTransaction(next);\n  }\n  _getContentRect() {\n    return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n  }\n  _performTransaction(transaction) {\n    this._transaction = transaction;\n    this.relayoutNow({\n      transaction: transaction,\n      animated: transaction.animated,\n      beforeLayout: () => {\n        // Get the initial layout infos for all views before the updates\n        // so we can figure out which views to add and remove.\n        if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n        // Apply the actions that occurred during this transaction\n        for (let action of transaction.actions) action();\n      },\n      afterLayout: () => {\n        // Get the final layout infos after the updates\n        if (transaction.animated) {\n          transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n          this._setupTransactionAnimations(transaction);\n        } else this._transaction = null;\n      },\n      afterAnimation: () => {\n        // Remove and reuse views when animations are done\n        if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())) {\n          this._children.delete(view);\n          this.reuseView(view);\n        }\n        this._transaction = null;\n        // Ensure DOM order is correct for accessibility after animations are complete\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        this._processTransactionQueue();\n      }\n    });\n  }\n  _setupTransactionAnimations(transaction) {\n    let {\n      initialMap: initialMap,\n      finalMap: finalMap\n    } = transaction;\n    // Store initial and final layout infos for animations\n    for (let [key, layoutInfo] of initialMap) if (finalMap.has(key))\n      // Store the initial layout info for use during animations.\n      transaction.initialLayoutInfo.set(key, layoutInfo);else\n      // This view was removed. Store the layout info for use\n      // in Layout#getFinalLayoutInfo during animations.\n      transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n    // Get initial layout infos for views that were added\n    for (let [key, layoutInfo] of finalMap) if (!initialMap.has(key)) {\n      let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n      transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n    }\n    // Figure out which views were removed.\n    for (let [key, view] of this._visibleViews)\n    // If an item has a width of 0, there is no need to remove it from the _visibleViews.\n    // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n    // added, removed... etc in a loop.\n    if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n      transaction.removed.set(key, view);\n      this._visibleViews.delete(key);\n      // In case something weird happened, where we have a view but no\n      // initial layout info, use the one attached to the view.\n      if (view.layoutInfo) {\n        if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n      }\n    }\n  }\n  constructor(options = {}) {\n    this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec)();\n    this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)();\n    this._reusableViews = {};\n    this._visibleLayoutInfos = new Map();\n    this._visibleViews = new Map();\n    this._renderedContent = new WeakMap();\n    this._children = new Set();\n    this._invalidationContext = null;\n    this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n    this._persistedKeys = new Set();\n    this._scrollAnimation = null;\n    this._isScrolling = false;\n    this._sizeUpdateQueue = new Map();\n    this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n    this._transaction = null;\n    this._nextTransaction = null;\n    this._transactionQueue = [];\n    var _options_transitionDuration;\n    // Set options from passed object if given\n    this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n    this.anchorScrollPosition = options.anchorScrollPosition || false;\n    this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    this.shouldOverscan = options.shouldOverscan !== false;\n    for (let key of [\"delegate\", \"size\", \"layout\", \"collection\"]) if (options[key]) this[key] = options[key];\n  }\n}\nexport { $38b9490c1cca8fc4$export$89be5a243e59c4b2 as Virtualizer };","map":{"version":3,"names":["easeOut","$3eb131dcf37ad5f8$export$57636bb43b1ccbb0","tween","$3eb131dcf37ad5f8$export$dc0b63720788090c","concatIterators","$fc36f9a046a9ce79$export$cfc14088dfefce5f","difference","$fc36f9a046a9ce79$export$acaf96a27438246b","isSetEqual","$fc36f9a046a9ce79$export$a8d0d0c8d1c5df64","OverscanManager","$364191b3decf3697$export$4455ee6afb38dcbb","Point","$3041db3296945e6e$export$baf26146a414f24a","Rect","$60423f92c7f9ad87$export$c79fc6492f3af13d","ReusableView","$ad1d98aa8f0c31b4$export$1a5223887c560441","Size","$ee1bfa90a957fb8a$export$cb6da89c6af1a8ec","Transaction","$8e135e531d8dcb66$export$febc5573c75cefb0","$38b9490c1cca8fc4$export$89be5a243e59c4b2","_setContentSize","size","_contentSize","delegate","setContentSize","_setContentOffset","offset","rect","x","y","_visibleRect","width","height","setVisibleRect","contentSize","visibleRect","_setVisibleRect","forceUpdate","current","equals","shouldOverscan","_overscanManager","shouldInvalidate","layout","_resetAnimatedContentOffset","relayoutNow","offsetChanged","pointEquals","sizeChanged","sizeEquals","updateSubviews","collection","_collection","data","_setData","_runTransaction","transitionDuration","reloadData","relayout","contentChanged","getItem","key","persistedKeys","_persistedKeys","isPersistedKey","has","k","layoutInfo","getLayoutInfo","parentKey","_layout","setLayout","animated","applyLayout","virtualizer","_getReuseType","content","type","getType","reuseType","getReusableView","_reusableViews","reusable","view","length","pop","viewType","_animatedContentOffset","isOrigin","copy","_renderView","reusableView","rendered","_renderContent","cached","_renderedContent","get","renderView","set","visibleViews","Array","from","_visibleViews","values","getView","getViewsOfType","filter","v","keyForView","keyAtPoint","point","layoutInfos","getVisibleLayoutInfos","intersects","willUnmount","cancelAnimationFrame","_relayoutRaf","context","_scrollAnimation","requestAnimationFrame","_invalidationContext","Object","assign","scrollAnchor","_getScrollAnchor","beforeLayout","validate","getContentSize","afterLayout","getVisibleRect","restoredScrollAnchor","_restoreScrollAnchor","contentOffsetX","contentOffsetY","Math","max","min","hasLayoutUpdates","transaction","_applyLayoutInfos","_enableTransitions","done","_disableTransitions","afterAnimation","setTimeout","_correctItemOrder","_isScrolling","_transaction","_visibleLayoutInfos","keys","_children","delete","add","beginAnimations","endAnimations","anchorScrollPosition","getScrollAnchor","corner","getCornerInRect","anchorScrollPositionAtTop","cornerAnchor","area","contentOffset","_context_transaction","finalAnchor","finalMap","adjustment","isTestEnv","isClientWidthMocked","getOwnPropertyNames","window","HTMLElement","prototype","includes","isClientHeightMocked","_getContentRect","getOverscannedRect","_getLayoutInfoMap","map","Map","visibleLayoutInfos","currentlyVisible","toAdd","toRemove","toUpdate","Set","item","removed","reuseView","initialLayoutInfo","_applyLayoutInfo","removeViews","_flushVisibleViews","_hasLayoutUpdates","afterRender","_transactionQueue","_processTransactionQueue","collectMetrics","viewsByParentKey","_view_layoutInfo","_viewsByParentKey_get","_view_layoutInfo1","_view_layoutInfo2","_view_layoutInfo3","push","buildTree","parent","views","children","renderWrapper","childViews","setVisibleViews","updated","cur","finalLayoutInfo","getFinalLayoutInfo","opacity","transform","prepareForReuse","updateItemSize","_sizeUpdateQueue","changed","startScrolling","endScrolling","scrollToItem","options","duration","shouldScrollX","shouldScrollY","offsetX","offsetY","minX","minY","maxX","maxY","scrollTo","cancel","Promise","resolve","then","clear","action","_startTransaction","_nextTransaction","actions","_endTransaction","level","next","shift","_performTransaction","initialMap","_setupTransactionAnimations","getInitialLayoutInfo","constructor","WeakMap","_options_transitionDuration","Virtualizer"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-stately/virtualizer/dist/Virtualizer.mjs"],"sourcesContent":["import {easeOut as $3eb131dcf37ad5f8$export$57636bb43b1ccbb0, tween as $3eb131dcf37ad5f8$export$dc0b63720788090c} from \"./tween.mjs\";\nimport {concatIterators as $fc36f9a046a9ce79$export$cfc14088dfefce5f, difference as $fc36f9a046a9ce79$export$acaf96a27438246b, isSetEqual as $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64} from \"./utils.mjs\";\nimport {OverscanManager as $364191b3decf3697$export$4455ee6afb38dcbb} from \"./OverscanManager.mjs\";\nimport {Point as $3041db3296945e6e$export$baf26146a414f24a} from \"./Point.mjs\";\nimport {Rect as $60423f92c7f9ad87$export$c79fc6492f3af13d} from \"./Rect.mjs\";\nimport {ReusableView as $ad1d98aa8f0c31b4$export$1a5223887c560441} from \"./ReusableView.mjs\";\nimport {Size as $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec} from \"./Size.mjs\";\nimport {Transaction as $8e135e531d8dcb66$export$febc5573c75cefb0} from \"./Transaction.mjs\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\n\n\nclass $38b9490c1cca8fc4$export$89be5a243e59c4b2 {\n    _setContentSize(size) {\n        this._contentSize = size;\n        this.delegate.setContentSize(size);\n    }\n    _setContentOffset(offset) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(offset.x, offset.y, this._visibleRect.width, this._visibleRect.height);\n        this.delegate.setVisibleRect(rect);\n    }\n    /**\n   * Get the size of the scrollable content.\n   */ get contentSize() {\n        return this._contentSize;\n    }\n    /**\n   * Get the collection view's currently visible rectangle.\n   */ get visibleRect() {\n        return this._visibleRect;\n    }\n    /**\n   * Set the collection view's currently visible rectangle.\n   */ set visibleRect(rect) {\n        this._setVisibleRect(rect);\n    }\n    _setVisibleRect(rect, forceUpdate = false) {\n        let current = this._visibleRect;\n        // Ignore if the rects are equal\n        if (rect.equals(current)) return;\n        if (this.shouldOverscan) this._overscanManager.setVisibleRect(rect);\n        let shouldInvalidate = this.layout && this.layout.shouldInvalidate(rect, this._visibleRect);\n        this._resetAnimatedContentOffset();\n        this._visibleRect = rect;\n        if (shouldInvalidate) // We are already in a layout effect when this method is called, so relayoutNow is appropriate.\n        this.relayoutNow({\n            offsetChanged: !rect.pointEquals(current),\n            sizeChanged: !rect.sizeEquals(current)\n        });\n        else this.updateSubviews(forceUpdate);\n    }\n    get collection() {\n        return this._collection;\n    }\n    set collection(data) {\n        this._setData(data);\n    }\n    _setData(data) {\n        if (data === this._collection) return;\n        if (this._collection) this._runTransaction(()=>{\n            this._collection = data;\n        }, this.transitionDuration > 0);\n        else {\n            this._collection = data;\n            this.reloadData();\n        }\n    }\n    /**\n   * Reloads the data from the data source and relayouts the collection view.\n   * Does not animate any changes. Equivalent to re-assigning the same data source\n   * to the collection view.\n   */ reloadData() {\n        this.relayout({\n            contentChanged: true\n        });\n    }\n    /**\n   * Returns the item with the given key.\n   */ getItem(key) {\n        return this._collection ? this._collection.getItem(key) : null;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ get persistedKeys() {\n        return this._persistedKeys;\n    }\n    /** The set of persisted keys are always present in the DOM, even if not currently in view. */ set persistedKeys(persistedKeys) {\n        if (!(0, $fc36f9a046a9ce79$export$a8d0d0c8d1c5df64)(persistedKeys, this._persistedKeys)) {\n            this._persistedKeys = persistedKeys;\n            this.updateSubviews();\n        }\n    }\n    /** Returns whether the given key, or an ancestor, is persisted. */ isPersistedKey(key) {\n        // Quick check if the key is directly in the set of persisted keys.\n        if (this._persistedKeys.has(key)) return true;\n        // If not, check if the key is an ancestor of any of the persisted keys.\n        for (let k of this._persistedKeys)while(k != null){\n            let layoutInfo = this.layout.getLayoutInfo(k);\n            if (!layoutInfo) break;\n            k = layoutInfo.parentKey;\n            if (k === key) return true;\n        }\n        return false;\n    }\n    /**\n   * Get the collection view's layout.\n   */ get layout() {\n        return this._layout;\n    }\n    /**\n   * Set the collection view's layout.\n   */ set layout(layout) {\n        this.setLayout(layout);\n    }\n    /**\n   * Sets the collection view's layout, optionally with an animated transition\n   * from the current layout to the new layout.\n   * @param layout The layout to switch to.\n   * @param animated Whether to animate the layout change.\n   */ setLayout(layout, animated = false) {\n        if (layout === this._layout) return;\n        let applyLayout = ()=>{\n            if (this._layout) // @ts-ignore\n            this._layout.virtualizer = null;\n            layout.virtualizer = this;\n            this._layout = layout;\n        };\n        if (animated) // Animated layout transitions are really simple, thanks to our transaction support.\n        // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n        else {\n            applyLayout();\n            this.relayout();\n        }\n    }\n    _getReuseType(layoutInfo, content) {\n        if (layoutInfo.type === \"item\" && content) {\n            let type = this.delegate.getType ? this.delegate.getType(content) : \"item\";\n            let reuseType = type === \"item\" ? \"item\" : layoutInfo.type + \"_\" + type;\n            return {\n                type: type,\n                reuseType: reuseType\n            };\n        }\n        return {\n            type: layoutInfo.type,\n            reuseType: layoutInfo.type\n        };\n    }\n    getReusableView(layoutInfo) {\n        let content = this.getItem(layoutInfo.key);\n        let { reuseType: reuseType } = this._getReuseType(layoutInfo, content);\n        if (!this._reusableViews[reuseType]) this._reusableViews[reuseType] = [];\n        let reusable = this._reusableViews[reuseType];\n        let view = reusable.length > 0 ? reusable.pop() : new (0, $ad1d98aa8f0c31b4$export$1a5223887c560441)(this);\n        view.viewType = reuseType;\n        if (!this._animatedContentOffset.isOrigin()) {\n            layoutInfo = layoutInfo.copy();\n            layoutInfo.rect.x += this._animatedContentOffset.x;\n            layoutInfo.rect.y += this._animatedContentOffset.y;\n        }\n        view.layoutInfo = layoutInfo;\n        this._renderView(view);\n        return view;\n    }\n    _renderView(reusableView) {\n        let { type: type, key: key } = reusableView.layoutInfo;\n        reusableView.content = this.getItem(key);\n        reusableView.rendered = this._renderContent(type, reusableView.content);\n    }\n    _renderContent(type, content) {\n        let cached = this._renderedContent.get(content);\n        if (cached != null) return cached;\n        let rendered = this.delegate.renderView(type, content);\n        if (content) this._renderedContent.set(content, rendered);\n        return rendered;\n    }\n    /**\n   * Returns an array of all currently visible views, including both\n   * item views and supplementary views.\n   */ get visibleViews() {\n        return Array.from(this._visibleViews.values());\n    }\n    /**\n   * Gets the visible view for the given type and key. Returns null if\n   * the view is not currently visible.\n   *\n   * @param key The key of the view to retrieve.\n   */ getView(key) {\n        return this._visibleViews.get(key) || null;\n    }\n    /**\n   * Returns an array of visible views matching the given type.\n   * @param type The view type to find.\n   */ getViewsOfType(type) {\n        return this.visibleViews.filter((v)=>v.layoutInfo && v.layoutInfo.type === type);\n    }\n    /**\n   * Returns the key for the given view. Returns null\n   * if the view is not currently visible.\n   */ keyForView(view) {\n        if (view && view.layoutInfo) return view.layoutInfo.key;\n        return null;\n    }\n    /**\n   * Returns the key for the item view currently at the given point.\n   */ keyAtPoint(point) {\n        let rect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(point.x, point.y, 1, 1);\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        // Layout may return multiple layout infos in the case of\n        // persisted keys, so find the first one that actually intersects.\n        for (let layoutInfo of layoutInfos){\n            if (layoutInfo.rect.intersects(rect)) return layoutInfo.key;\n        }\n        return null;\n    }\n    /**\n   * Cleanup for when the Virtualizer will be unmounted.\n   */ willUnmount() {\n        cancelAnimationFrame(this._relayoutRaf);\n    }\n    /**\n   * Triggers a layout invalidation, and updates the visible subviews.\n   */ relayout(context = {}) {\n        // Ignore relayouts while animating the scroll position\n        if (this._scrollAnimation || typeof requestAnimationFrame === \"undefined\") return;\n        // If we already scheduled a relayout, extend the invalidation\n        // context so we coalesce multiple relayouts in the same frame.\n        if (this._invalidationContext) {\n            Object.assign(this._invalidationContext, context);\n            return;\n        }\n        this._invalidationContext = context;\n    }\n    /**\n   * Performs a relayout immediately. Prefer {@link relayout} over this method\n   * where possible, since it coalesces multiple layout passes in the same tick.\n   */ relayoutNow(context = this._invalidationContext || {}) {\n        // Cancel the scheduled relayout, since we're doing it now.\n        if (this._relayoutRaf) {\n            cancelAnimationFrame(this._relayoutRaf);\n            this._relayoutRaf = null;\n            // Update the provided context with the current invalidationContext since we are cancelling\n            // a scheduled relayoutNow call that has this._invalidationContext set as its default context arg (relayoutNow() in relayout)\n            context = {\n                ...this._invalidationContext,\n                ...context\n            };\n        }\n        // Reset the invalidation context\n        this._invalidationContext = null;\n        // Do nothing if we don't have a layout or content, or we are\n        // in the middle of an animated scroll transition.\n        if (!this.layout || !this._collection || this._scrollAnimation) return;\n        let scrollAnchor = this._getScrollAnchor();\n        // Trigger the beforeLayout hook, if provided\n        if (typeof context.beforeLayout === \"function\") context.beforeLayout();\n        // Validate the layout\n        this.layout.validate(context);\n        this._setContentSize(this.layout.getContentSize());\n        // Trigger the afterLayout hook, if provided\n        if (typeof context.afterLayout === \"function\") context.afterLayout();\n        // Adjust scroll position based on scroll anchor, and constrain.\n        // If the content changed, scroll to the top.\n        let visibleRect = this.getVisibleRect();\n        let restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n        let contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n        let contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n        contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n        contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n        let hasLayoutUpdates = false;\n        if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n            // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n            // Save the difference between the current and new content offsets, and apply it to the\n            // individual content items instead. At the end of the animation, we'll reset and set the\n            // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n            // the scroll animation and the content animation.\n            if (context.animated || !this._animatedContentOffset.isOrigin()) {\n                this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n                this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n                hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n            } else this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(contentOffsetX, contentOffsetY));\n        } else hasLayoutUpdates = this.updateSubviews(context.contentChanged);\n        // Apply layout infos, unless this is coming from an animated transaction\n        if (!(context.transaction && context.animated)) this._applyLayoutInfos();\n        // Wait for animations, and apply the afterAnimation hook, if provided\n        if (context.animated && hasLayoutUpdates) {\n            this._enableTransitions();\n            let done = ()=>{\n                this._disableTransitions();\n                // Reset scroll position after animations (see above comment).\n                if (!this._animatedContentOffset.isOrigin()) {\n                    // Get the content offset to scroll to, taking _animatedContentOffset into account.\n                    let { x: x, y: y } = this.getVisibleRect();\n                    this._resetAnimatedContentOffset();\n                    this._setContentOffset(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y));\n                }\n                if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n            };\n            // Sometimes the animation takes slightly longer than expected.\n            setTimeout(done, this.transitionDuration + 100);\n            return;\n        } else if (typeof context.afterAnimation === \"function\") context.afterAnimation();\n    }\n    /**\n   * Corrects DOM order of visible views to match item order of collection.\n   */ _correctItemOrder() {\n        // Defer until after scrolling and animated transactions are complete\n        if (this._isScrolling || this._transaction) return;\n        for (let key of this._visibleLayoutInfos.keys()){\n            let view = this._visibleViews.get(key);\n            this._children.delete(view);\n            this._children.add(view);\n        }\n    }\n    _enableTransitions() {\n        this.delegate.beginAnimations();\n    }\n    _disableTransitions() {\n        this.delegate.endAnimations();\n    }\n    _getScrollAnchor() {\n        if (!this.anchorScrollPosition) return null;\n        let visibleRect = this.getVisibleRect();\n        // Ask the delegate to provide a scroll anchor, if possible\n        if (this.delegate.getScrollAnchor) {\n            let key = this.delegate.getScrollAnchor(visibleRect);\n            if (key != null) {\n                let layoutInfo = this.layout.getLayoutInfo(key);\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let key = layoutInfo.key;\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    return {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        // No need to anchor the scroll position if it is at the top\n        if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) return null;\n        // Find a view with a visible corner that has the smallest distance to the top of the collection view\n        let cornerAnchor = null;\n        for (let [key, view] of this._visibleViews){\n            let layoutInfo = view.layoutInfo;\n            if (layoutInfo && layoutInfo.rect.area > 0) {\n                let corner = layoutInfo.rect.getCornerInRect(visibleRect);\n                if (corner) {\n                    let offset = layoutInfo.rect[corner].y - visibleRect.y;\n                    if (!cornerAnchor || offset < cornerAnchor.offset) cornerAnchor = {\n                        key: key,\n                        layoutInfo: layoutInfo,\n                        corner: corner,\n                        offset: offset\n                    };\n                }\n            }\n        }\n        return cornerAnchor;\n    }\n    _restoreScrollAnchor(scrollAnchor, context) {\n        let contentOffset = this.getVisibleRect();\n        if (scrollAnchor) {\n            var _context_transaction;\n            let finalAnchor = ((_context_transaction = context.transaction) === null || _context_transaction === void 0 ? void 0 : _context_transaction.animated) ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.key);\n            if (finalAnchor) {\n                let adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n                contentOffset.y += adjustment;\n            }\n        }\n        return contentOffset;\n    }\n    getVisibleRect() {\n        let v = this.visibleRect;\n        let x = v.x - this._animatedContentOffset.x;\n        let y = v.y - this._animatedContentOffset.y;\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(x, y, v.width, v.height);\n    }\n    getVisibleLayoutInfos() {\n        let isTestEnv = false;\n        let isClientWidthMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes(\"clientWidth\");\n        let isClientHeightMocked = Object.getOwnPropertyNames(window.HTMLElement.prototype).includes(\"clientHeight\");\n        let rect;\n        if (isTestEnv && !(isClientWidthMocked && isClientHeightMocked)) rect = this._getContentRect();\n        else rect = this.shouldOverscan ? this._overscanManager.getOverscannedRect() : this.getVisibleRect();\n        this._visibleLayoutInfos = this._getLayoutInfoMap(rect);\n        return this._visibleLayoutInfos;\n    }\n    _getLayoutInfoMap(rect, copy = false) {\n        let layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n        let map = new Map;\n        for (let layoutInfo of layoutInfos){\n            if (copy) layoutInfo = layoutInfo.copy();\n            map.set(layoutInfo.key, layoutInfo);\n        }\n        return map;\n    }\n    updateSubviews(forceUpdate = false) {\n        if (!this._collection) return;\n        let visibleLayoutInfos = this.getVisibleLayoutInfos();\n        let currentlyVisible = this._visibleViews;\n        let toAdd, toRemove, toUpdate;\n        // If this is a force update, remove and re-add all views.\n        // Otherwise, find and update the diff.\n        if (forceUpdate) {\n            toAdd = visibleLayoutInfos;\n            toRemove = currentlyVisible;\n            toUpdate = new Set();\n        } else {\n            ({ toAdd: toAdd, toRemove: toRemove, toUpdate: toUpdate } = (0, $fc36f9a046a9ce79$export$acaf96a27438246b)(currentlyVisible, visibleLayoutInfos));\n            for (let key of toUpdate){\n                let view = currentlyVisible.get(key);\n                if (!view || !view.layoutInfo) continue;\n                let item = this.getItem(visibleLayoutInfos.get(key).key);\n                if (view.content === item) toUpdate.delete(key);\n                else {\n                    // If the view type changes, delete and recreate the view instead of updating\n                    let { reuseType: reuseType } = this._getReuseType(view.layoutInfo, item);\n                    if (view.viewType !== reuseType) {\n                        toUpdate.delete(key);\n                        toAdd.add(key);\n                        toRemove.add(key);\n                    }\n                }\n            }\n            // We are done if the sets are equal\n            if (toAdd.size === 0 && toRemove.size === 0 && toUpdate.size === 0) {\n                if (this._transaction) this._applyLayoutInfos();\n                return;\n            }\n        }\n        // Track views that should be removed. They are not removed from\n        // the DOM immediately, since we may reuse and need to re-insert\n        // them back into the DOM anyway.\n        let removed = new Set();\n        for (let key of toRemove.keys()){\n            let view = this._visibleViews.get(key);\n            if (view) {\n                removed.add(view);\n                this._visibleViews.delete(key);\n                // If we are in the middle of a transaction, wait until the end\n                // of the animations to remove the views from the DOM. Also means\n                // we can't reuse those views immediately.\n                if (this._transaction) this._transaction.toRemove.set(key, view);\n                else this.reuseView(view);\n            }\n        }\n        for (let key of toAdd.keys()){\n            let layoutInfo = visibleLayoutInfos.get(key);\n            let view;\n            // If we're in a transaction, and a layout change happens\n            // during the animations such that a view that was going\n            // to be removed is now not, we don't create a new view\n            // since the old one is still in the DOM, marked as toRemove.\n            if (this._transaction) {\n                // if transaction, get initial layout attributes for the animation\n                if (this._transaction.initialLayoutInfo.has(key)) layoutInfo = this._transaction.initialLayoutInfo.get(key);\n                view = this._transaction.toRemove.get(key);\n                if (view) {\n                    this._transaction.toRemove.delete(key);\n                    this._applyLayoutInfo(view, layoutInfo);\n                }\n            }\n            if (!view) {\n                // Create or reuse a view for this row\n                view = this.getReusableView(layoutInfo);\n                // Add the view to the DOM if needed\n                if (!removed.has(view)) this._children.add(view);\n            }\n            this._visibleViews.set(key, view);\n            removed.delete(view);\n        }\n        for (let key of toUpdate){\n            let view = currentlyVisible.get(key);\n            this._renderedContent.delete(key);\n            this._renderView(view);\n        }\n        // Remove the remaining rows to delete from the DOM\n        if (!this._transaction) this.removeViews(removed);\n        this._correctItemOrder();\n        this._flushVisibleViews();\n        let hasLayoutUpdates = this._transaction && (toAdd.size > 0 || toRemove.size > 0 || this._hasLayoutUpdates());\n        if (hasLayoutUpdates) requestAnimationFrame(()=>{\n            // If we're in a transaction, apply animations to visible views\n            // and \"to be removed\" views, which animate off screen.\n            if (this._transaction) requestAnimationFrame(()=>this._applyLayoutInfos());\n        });\n        return hasLayoutUpdates;\n    }\n    afterRender() {\n        if (this._transactionQueue.length > 0) this._processTransactionQueue();\n        else if (this._invalidationContext) this.relayoutNow();\n        if (this.shouldOverscan) this._overscanManager.collectMetrics();\n    }\n    _flushVisibleViews() {\n        // CollectionVirtualizer deals with a flattened set of LayoutInfos, but they can represent hierarchy\n        // by referencing a parentKey. Just before rendering the visible views, we rebuild this hierarchy\n        // by creating a mapping of views by parent key and recursively calling the delegate's renderWrapper\n        // method to build the final tree.\n        let viewsByParentKey = new Map([\n            [\n                null,\n                []\n            ]\n        ]);\n        for (let view of this._children){\n            var _view_layoutInfo, _viewsByParentKey_get, _view_layoutInfo1, _view_layoutInfo2, _view_layoutInfo3;\n            if (((_view_layoutInfo = view.layoutInfo) === null || _view_layoutInfo === void 0 ? void 0 : _view_layoutInfo.parentKey) != null && !viewsByParentKey.has(view.layoutInfo.parentKey)) viewsByParentKey.set(view.layoutInfo.parentKey, []);\n            (_viewsByParentKey_get = viewsByParentKey.get((_view_layoutInfo1 = view.layoutInfo) === null || _view_layoutInfo1 === void 0 ? void 0 : _view_layoutInfo1.parentKey)) === null || _viewsByParentKey_get === void 0 ? void 0 : _viewsByParentKey_get.push(view);\n            if (!viewsByParentKey.has((_view_layoutInfo2 = view.layoutInfo) === null || _view_layoutInfo2 === void 0 ? void 0 : _view_layoutInfo2.key)) viewsByParentKey.set((_view_layoutInfo3 = view.layoutInfo) === null || _view_layoutInfo3 === void 0 ? void 0 : _view_layoutInfo3.key, []);\n        }\n        let buildTree = (parent, views)=>views.map((view)=>{\n                let children = viewsByParentKey.get(view.layoutInfo.key);\n                return this.delegate.renderWrapper(parent, view, children, (childViews)=>buildTree(view, childViews));\n            });\n        let children = buildTree(null, viewsByParentKey.get(null));\n        this.delegate.setVisibleViews(children);\n    }\n    _applyLayoutInfo(view, layoutInfo) {\n        if (view.layoutInfo === layoutInfo) return false;\n        view.layoutInfo = layoutInfo;\n        return true;\n    }\n    _applyLayoutInfos() {\n        let updated = false;\n        // Apply layout infos to visible views\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        // Apply final layout infos for views that will be removed\n        if (this._transaction) {\n            for (let view of this._transaction.toRemove.values()){\n                let cur = view.layoutInfo;\n                if ((cur === null || cur === void 0 ? void 0 : cur.key) != null) {\n                    let layoutInfo = this.layout.getLayoutInfo(cur.key);\n                    if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n                }\n            }\n            for (let view of this._transaction.removed.values()){\n                let cur = view.layoutInfo;\n                let layoutInfo = this._transaction.finalLayoutInfo.get(cur.key) || cur;\n                layoutInfo = this.layout.getFinalLayoutInfo(layoutInfo.copy());\n                if (this._applyLayoutInfo(view, layoutInfo)) updated = true;\n            }\n        }\n        if (updated) this._flushVisibleViews();\n    }\n    _hasLayoutUpdates() {\n        if (!this._transaction) return false;\n        for (let view of this._visibleViews.values()){\n            let cur = view.layoutInfo;\n            if (!cur) return true;\n            let layoutInfo = this.layout.getLayoutInfo(cur.key);\n            if (// Uses equals rather than pointEquals so that width/height changes are taken into account\n            !cur.rect.equals(layoutInfo.rect) || cur.opacity !== layoutInfo.opacity || cur.transform !== layoutInfo.transform) return true;\n        }\n        return false;\n    }\n    reuseView(view) {\n        view.prepareForReuse();\n        this._reusableViews[view.viewType].push(view);\n    }\n    removeViews(toRemove) {\n        for (let view of toRemove)this._children.delete(view);\n    }\n    updateItemSize(key, size) {\n        // TODO: we should be able to invalidate a single index path\n        // @ts-ignore\n        if (!this.layout.updateItemSize) return;\n        // If the scroll position is currently animating, add the update\n        // to a queue to be processed after the animation is complete.\n        if (this._scrollAnimation) {\n            this._sizeUpdateQueue.set(key, size);\n            return;\n        }\n        // @ts-ignore\n        let changed = this.layout.updateItemSize(key, size);\n        if (changed) this.relayout();\n    }\n    startScrolling() {\n        this._isScrolling = true;\n    }\n    endScrolling() {\n        this._isScrolling = false;\n        this._correctItemOrder();\n        this._flushVisibleViews();\n    }\n    _resetAnimatedContentOffset() {\n        // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n        if (!this._animatedContentOffset.isOrigin()) {\n            this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n            this._applyLayoutInfos();\n        }\n    }\n    /**\n   * Scrolls the item with the given key into view, optionally with an animation.\n   * @param key The key of the item to scroll into view.\n   * @param duration The duration of the scroll animation.\n   */ scrollToItem(key, options) {\n        // key can be 0, so check if null or undefined\n        if (key == null) return;\n        let layoutInfo = this.layout.getLayoutInfo(key);\n        if (!layoutInfo) return;\n        let { duration: duration = 300, shouldScrollX: shouldScrollX = true, shouldScrollY: shouldScrollY = true, offsetX: offsetX = 0, offsetY: offsetY = 0 } = options;\n        let x = this.visibleRect.x;\n        let y = this.visibleRect.y;\n        let minX = layoutInfo.rect.x - offsetX;\n        let minY = layoutInfo.rect.y - offsetY;\n        let maxX = x + this.visibleRect.width;\n        let maxY = y + this.visibleRect.height;\n        if (shouldScrollX) {\n            if (minX <= x || maxX === 0) x = minX;\n            else if (layoutInfo.rect.maxX > maxX) x += layoutInfo.rect.maxX - maxX;\n        }\n        if (shouldScrollY) {\n            if (minY <= y || maxY === 0) y = minY;\n            else if (layoutInfo.rect.maxY > maxY) y += layoutInfo.rect.maxY - maxY;\n        }\n        return this.scrollTo(new (0, $3041db3296945e6e$export$baf26146a414f24a)(x, y), duration);\n    }\n    /**\n   * Performs an animated scroll to the given offset.\n   * @param offset - The offset to scroll to.\n   * @param duration The duration of the animation.\n   * @returns A promise that resolves when the animation is complete.\n   */ scrollTo(offset, duration = 300) {\n        // Cancel the current scroll animation\n        if (this._scrollAnimation) {\n            this._scrollAnimation.cancel();\n            this._scrollAnimation = null;\n        }\n        // Set the content offset synchronously if the duration is zero\n        if (duration <= 0 || this.visibleRect.pointEquals(offset)) {\n            this._setContentOffset(offset);\n            return Promise.resolve();\n        }\n        this.startScrolling();\n        this._scrollAnimation = (0, $3eb131dcf37ad5f8$export$dc0b63720788090c)(this.visibleRect, offset, duration, (0, $3eb131dcf37ad5f8$export$57636bb43b1ccbb0), (offset)=>{\n            this._setContentOffset(offset);\n        });\n        this._scrollAnimation.then(()=>{\n            this._scrollAnimation = null;\n            // Process view size updates that occurred during the animation.\n            // Only views that are still visible will be actually updated.\n            for (let [key, size] of this._sizeUpdateQueue)this.updateItemSize(key, size);\n            this._sizeUpdateQueue.clear();\n            this.relayout();\n            this._processTransactionQueue();\n            this.endScrolling();\n        });\n        return this._scrollAnimation;\n    }\n    _runTransaction(action, animated) {\n        this._startTransaction();\n        if (this._nextTransaction) this._nextTransaction.actions.push(action);\n        this._endTransaction(animated);\n    }\n    _startTransaction() {\n        if (!this._nextTransaction) this._nextTransaction = new (0, $8e135e531d8dcb66$export$febc5573c75cefb0);\n        this._nextTransaction.level++;\n    }\n    _endTransaction(animated) {\n        if (!this._nextTransaction) return false;\n        // Save whether the transaction should be animated.\n        if (animated != null) this._nextTransaction.animated = animated;\n        // If we haven't reached level 0, we are still in a\n        // nested transaction. Wait for the parent to end.\n        if (--this._nextTransaction.level > 0) return false;\n        // Do nothing for empty transactions\n        if (this._nextTransaction.actions.length === 0) {\n            this._nextTransaction = null;\n            return false;\n        }\n        // Default animations to true\n        if (this._nextTransaction.animated == null) this._nextTransaction.animated = true;\n        // Enqueue the transaction\n        this._transactionQueue.push(this._nextTransaction);\n        this._nextTransaction = null;\n        return true;\n    }\n    _processTransactionQueue() {\n        // If the current transaction is animating, wait until the end\n        // to process the next transaction.\n        if (this._transaction || this._scrollAnimation) return;\n        let next = this._transactionQueue.shift();\n        if (next) this._performTransaction(next);\n    }\n    _getContentRect() {\n        return new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d)(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n    _performTransaction(transaction) {\n        this._transaction = transaction;\n        this.relayoutNow({\n            transaction: transaction,\n            animated: transaction.animated,\n            beforeLayout: ()=>{\n                // Get the initial layout infos for all views before the updates\n                // so we can figure out which views to add and remove.\n                if (transaction.animated) transaction.initialMap = this._getLayoutInfoMap(this._getContentRect(), true);\n                // Apply the actions that occurred during this transaction\n                for (let action of transaction.actions)action();\n            },\n            afterLayout: ()=>{\n                // Get the final layout infos after the updates\n                if (transaction.animated) {\n                    transaction.finalMap = this._getLayoutInfoMap(this._getContentRect());\n                    this._setupTransactionAnimations(transaction);\n                } else this._transaction = null;\n            },\n            afterAnimation: ()=>{\n                // Remove and reuse views when animations are done\n                if (transaction.toRemove.size > 0 || transaction.removed.size > 0) for (let view of (0, $fc36f9a046a9ce79$export$cfc14088dfefce5f)(transaction.toRemove.values(), transaction.removed.values())){\n                    this._children.delete(view);\n                    this.reuseView(view);\n                }\n                this._transaction = null;\n                // Ensure DOM order is correct for accessibility after animations are complete\n                this._correctItemOrder();\n                this._flushVisibleViews();\n                this._processTransactionQueue();\n            }\n        });\n    }\n    _setupTransactionAnimations(transaction) {\n        let { initialMap: initialMap, finalMap: finalMap } = transaction;\n        // Store initial and final layout infos for animations\n        for (let [key, layoutInfo] of initialMap)if (finalMap.has(key)) // Store the initial layout info for use during animations.\n        transaction.initialLayoutInfo.set(key, layoutInfo);\n        else // This view was removed. Store the layout info for use\n        // in Layout#getFinalLayoutInfo during animations.\n        transaction.finalLayoutInfo.set(layoutInfo.key, layoutInfo);\n        // Get initial layout infos for views that were added\n        for (let [key, layoutInfo] of finalMap)if (!initialMap.has(key)) {\n            let initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.copy());\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n        }\n        // Figure out which views were removed.\n        for (let [key, view] of this._visibleViews)// If an item has a width of 0, there is no need to remove it from the _visibleViews.\n        // Removing an item with  width of 0 can cause a loop where the item gets added, removed,\n        // added, removed... etc in a loop.\n        if (!finalMap.has(key) && view.layoutInfo.rect.width > 0) {\n            transaction.removed.set(key, view);\n            this._visibleViews.delete(key);\n            // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n            if (view.layoutInfo) {\n                if (!transaction.finalLayoutInfo.has(view.layoutInfo.key)) transaction.finalLayoutInfo.set(view.layoutInfo.key, view.layoutInfo);\n            }\n        }\n    }\n    constructor(options = {}){\n        this._contentSize = new (0, $ee1bfa90a957fb8a$export$cb6da89c6af1a8ec);\n        this._visibleRect = new (0, $60423f92c7f9ad87$export$c79fc6492f3af13d);\n        this._reusableViews = {};\n        this._visibleLayoutInfos = new Map();\n        this._visibleViews = new Map();\n        this._renderedContent = new WeakMap();\n        this._children = new Set();\n        this._invalidationContext = null;\n        this._overscanManager = new (0, $364191b3decf3697$export$4455ee6afb38dcbb)();\n        this._persistedKeys = new Set();\n        this._scrollAnimation = null;\n        this._isScrolling = false;\n        this._sizeUpdateQueue = new Map();\n        this._animatedContentOffset = new (0, $3041db3296945e6e$export$baf26146a414f24a)(0, 0);\n        this._transaction = null;\n        this._nextTransaction = null;\n        this._transactionQueue = [];\n        var _options_transitionDuration;\n        // Set options from passed object if given\n        this.transitionDuration = (_options_transitionDuration = options.transitionDuration) !== null && _options_transitionDuration !== void 0 ? _options_transitionDuration : 500;\n        this.anchorScrollPosition = options.anchorScrollPosition || false;\n        this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n        this.shouldOverscan = options.shouldOverscan !== false;\n        for (let key of [\n            \"delegate\",\n            \"size\",\n            \"layout\",\n            \"collection\"\n        ])if (options[key]) this[key] = options[key];\n    }\n}\n\n\nexport {$38b9490c1cca8fc4$export$89be5a243e59c4b2 as Virtualizer};\n//# sourceMappingURL=Virtualizer.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}