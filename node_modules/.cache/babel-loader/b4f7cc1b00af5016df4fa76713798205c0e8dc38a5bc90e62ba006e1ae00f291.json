{"ast":null,"code":"import { getFirstItem as $eIXPM$getFirstItem, getChildNodes as $eIXPM$getChildNodes, getNthItem as $eIXPM$getNthItem } from \"@react-stately/collections\";\nimport { GridKeyboardDelegate as $eIXPM$GridKeyboardDelegate } from \"@react-aria/grid\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nclass $0ba3c81c7f1caedd$export$da43f8f5cb04028d extends (0, $eIXPM$GridKeyboardDelegate) {\n  isCell(node) {\n    return node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\";\n  }\n  getKeyBelow(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a column, then focus the first child column if any,\n    // or find the corresponding cell in the first row.\n    if (startItem.type === \"column\") {\n      let child = (0, $eIXPM$getFirstItem)((0, $eIXPM$getChildNodes)(startItem, this.collection));\n      if (child) return child.key;\n      let firstKey = this.getFirstKey();\n      if (firstKey == null) return;\n      let firstItem = this.collection.getItem(firstKey);\n      return (0, $eIXPM$getNthItem)((0, $eIXPM$getChildNodes)(firstItem, this.collection), startItem.index).key;\n    }\n    return super.getKeyBelow(key);\n  }\n  getKeyAbove(key) {\n    let startItem = this.collection.getItem(key);\n    if (!startItem) return;\n    // If focus was on a column, focus the parent column if any\n    if (startItem.type === \"column\") {\n      let parent = this.collection.getItem(startItem.parentKey);\n      if (parent && parent.type === \"column\") return parent.key;\n      return;\n    }\n    // only return above row key if not header row\n    let superKey = super.getKeyAbove(key);\n    if (superKey != null && this.collection.getItem(superKey).type !== \"headerrow\") return superKey;\n    // If no item was found, and focus was on a cell, then focus the\n    // corresponding column header.\n    if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;\n    // If focus was on a row, then focus the first column header.\n    return this.collection.columns[0].key;\n  }\n  findNextColumnKey(column) {\n    // Search following columns\n    let key = this.findNextKey(column.key, item => item.type === \"column\");\n    if (key != null) return key;\n    // Wrap around to the first column\n    let row = this.collection.headerRows[column.level];\n    for (let item of (0, $eIXPM$getChildNodes)(row, this.collection)) {\n      if (item.type === \"column\") return item.key;\n    }\n  }\n  findPreviousColumnKey(column) {\n    // Search previous columns\n    let key = this.findPreviousKey(column.key, item => item.type === \"column\");\n    if (key != null) return key;\n    // Wrap around to the last column\n    let row = this.collection.headerRows[column.level];\n    let childNodes = [...(0, $eIXPM$getChildNodes)(row, this.collection)];\n    for (let i = childNodes.length - 1; i >= 0; i--) {\n      let item = childNodes[i];\n      if (item.type === \"column\") return item.key;\n    }\n  }\n  getKeyRightOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus was on a column, then focus the next column\n    if (item.type === \"column\") return this.direction === \"rtl\" ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);\n    return super.getKeyRightOf(key);\n  }\n  getKeyLeftOf(key) {\n    let item = this.collection.getItem(key);\n    if (!item) return;\n    // If focus was on a column, then focus the previous column\n    if (item.type === \"column\") return this.direction === \"rtl\" ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);\n    return super.getKeyLeftOf(key);\n  }\n  getKeyForSearch(search, fromKey) {\n    if (!this.collator) return null;\n    let collection = this.collection;\n    let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n    if (key == null) return null;\n    // If the starting key is a cell, search from its parent row.\n    let startItem = collection.getItem(key);\n    if (startItem.type === \"cell\") key = startItem.parentKey;\n    let hasWrapped = false;\n    while (key != null) {\n      let item = collection.getItem(key);\n      // Check each of the row header cells in this row for a match\n      for (let cell of (0, $eIXPM$getChildNodes)(item, this.collection)) {\n        let column = collection.columns[cell.index];\n        if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n          let substring = cell.textValue.slice(0, search.length);\n          if (this.collator.compare(substring, search) === 0) {\n            // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n            let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n            return fromItem.type === \"cell\" ? cell.key : item.key;\n          }\n        }\n      }\n      key = this.getKeyBelow(key);\n      // Wrap around when reaching the end of the collection\n      if (key == null && !hasWrapped) {\n        key = this.getFirstKey();\n        hasWrapped = true;\n      }\n    }\n    return null;\n  }\n}\nexport { $0ba3c81c7f1caedd$export$da43f8f5cb04028d as TableKeyboardDelegate };","map":{"version":3,"names":["getFirstItem","$eIXPM$getFirstItem","getChildNodes","$eIXPM$getChildNodes","getNthItem","$eIXPM$getNthItem","GridKeyboardDelegate","$eIXPM$GridKeyboardDelegate","$0ba3c81c7f1caedd$export$da43f8f5cb04028d","isCell","node","type","getKeyBelow","key","startItem","collection","getItem","child","firstKey","getFirstKey","firstItem","index","getKeyAbove","parent","parentKey","superKey","columns","findNextColumnKey","column","findNextKey","item","row","headerRows","level","findPreviousColumnKey","findPreviousKey","childNodes","i","length","getKeyRightOf","direction","getKeyLeftOf","getKeyForSearch","search","fromKey","collator","hasWrapped","cell","rowHeaderColumnKeys","has","textValue","substring","slice","compare","fromItem","TableKeyboardDelegate"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-aria/table/dist/TableKeyboardDelegate.mjs"],"sourcesContent":["import {getFirstItem as $eIXPM$getFirstItem, getChildNodes as $eIXPM$getChildNodes, getNthItem as $eIXPM$getNthItem} from \"@react-stately/collections\";\nimport {GridKeyboardDelegate as $eIXPM$GridKeyboardDelegate} from \"@react-aria/grid\";\n\n/*\n * Copyright 2022 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\nclass $0ba3c81c7f1caedd$export$da43f8f5cb04028d extends (0, $eIXPM$GridKeyboardDelegate) {\n    isCell(node) {\n        return node.type === \"cell\" || node.type === \"rowheader\" || node.type === \"column\";\n    }\n    getKeyBelow(key) {\n        let startItem = this.collection.getItem(key);\n        if (!startItem) return;\n        // If focus was on a column, then focus the first child column if any,\n        // or find the corresponding cell in the first row.\n        if (startItem.type === \"column\") {\n            let child = (0, $eIXPM$getFirstItem)((0, $eIXPM$getChildNodes)(startItem, this.collection));\n            if (child) return child.key;\n            let firstKey = this.getFirstKey();\n            if (firstKey == null) return;\n            let firstItem = this.collection.getItem(firstKey);\n            return (0, $eIXPM$getNthItem)((0, $eIXPM$getChildNodes)(firstItem, this.collection), startItem.index).key;\n        }\n        return super.getKeyBelow(key);\n    }\n    getKeyAbove(key) {\n        let startItem = this.collection.getItem(key);\n        if (!startItem) return;\n        // If focus was on a column, focus the parent column if any\n        if (startItem.type === \"column\") {\n            let parent = this.collection.getItem(startItem.parentKey);\n            if (parent && parent.type === \"column\") return parent.key;\n            return;\n        }\n        // only return above row key if not header row\n        let superKey = super.getKeyAbove(key);\n        if (superKey != null && this.collection.getItem(superKey).type !== \"headerrow\") return superKey;\n        // If no item was found, and focus was on a cell, then focus the\n        // corresponding column header.\n        if (this.isCell(startItem)) return this.collection.columns[startItem.index].key;\n        // If focus was on a row, then focus the first column header.\n        return this.collection.columns[0].key;\n    }\n    findNextColumnKey(column) {\n        // Search following columns\n        let key = this.findNextKey(column.key, (item)=>item.type === \"column\");\n        if (key != null) return key;\n        // Wrap around to the first column\n        let row = this.collection.headerRows[column.level];\n        for (let item of (0, $eIXPM$getChildNodes)(row, this.collection)){\n            if (item.type === \"column\") return item.key;\n        }\n    }\n    findPreviousColumnKey(column) {\n        // Search previous columns\n        let key = this.findPreviousKey(column.key, (item)=>item.type === \"column\");\n        if (key != null) return key;\n        // Wrap around to the last column\n        let row = this.collection.headerRows[column.level];\n        let childNodes = [\n            ...(0, $eIXPM$getChildNodes)(row, this.collection)\n        ];\n        for(let i = childNodes.length - 1; i >= 0; i--){\n            let item = childNodes[i];\n            if (item.type === \"column\") return item.key;\n        }\n    }\n    getKeyRightOf(key) {\n        let item = this.collection.getItem(key);\n        if (!item) return;\n        // If focus was on a column, then focus the next column\n        if (item.type === \"column\") return this.direction === \"rtl\" ? this.findPreviousColumnKey(item) : this.findNextColumnKey(item);\n        return super.getKeyRightOf(key);\n    }\n    getKeyLeftOf(key) {\n        let item = this.collection.getItem(key);\n        if (!item) return;\n        // If focus was on a column, then focus the previous column\n        if (item.type === \"column\") return this.direction === \"rtl\" ? this.findNextColumnKey(item) : this.findPreviousColumnKey(item);\n        return super.getKeyLeftOf(key);\n    }\n    getKeyForSearch(search, fromKey) {\n        if (!this.collator) return null;\n        let collection = this.collection;\n        let key = fromKey !== null && fromKey !== void 0 ? fromKey : this.getFirstKey();\n        if (key == null) return null;\n        // If the starting key is a cell, search from its parent row.\n        let startItem = collection.getItem(key);\n        if (startItem.type === \"cell\") key = startItem.parentKey;\n        let hasWrapped = false;\n        while(key != null){\n            let item = collection.getItem(key);\n            // Check each of the row header cells in this row for a match\n            for (let cell of (0, $eIXPM$getChildNodes)(item, this.collection)){\n                let column = collection.columns[cell.index];\n                if (collection.rowHeaderColumnKeys.has(column.key) && cell.textValue) {\n                    let substring = cell.textValue.slice(0, search.length);\n                    if (this.collator.compare(substring, search) === 0) {\n                        // If we started on a cell, end on the matching cell. Otherwise, end on the row.\n                        let fromItem = fromKey != null ? collection.getItem(fromKey) : startItem;\n                        return fromItem.type === \"cell\" ? cell.key : item.key;\n                    }\n                }\n            }\n            key = this.getKeyBelow(key);\n            // Wrap around when reaching the end of the collection\n            if (key == null && !hasWrapped) {\n                key = this.getFirstKey();\n                hasWrapped = true;\n            }\n        }\n        return null;\n    }\n}\n\n\nexport {$0ba3c81c7f1caedd$export$da43f8f5cb04028d as TableKeyboardDelegate};\n//# sourceMappingURL=TableKeyboardDelegate.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}