{"ast":null,"code":"/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */class $a02d57049d202695$export$d085fb9e920b5ca7 {\n  *[Symbol.iterator]() {\n    yield* this.iterable;\n  }\n  get size() {\n    return this.keyMap.size;\n  }\n  getKeys() {\n    return this.keyMap.keys();\n  }\n  getKeyBefore(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.prevKey : null;\n  }\n  getKeyAfter(key) {\n    let node = this.keyMap.get(key);\n    return node ? node.nextKey : null;\n  }\n  getFirstKey() {\n    return this.firstKey;\n  }\n  getLastKey() {\n    return this.lastKey;\n  }\n  getItem(key) {\n    return this.keyMap.get(key);\n  }\n  at(idx) {\n    const keys = [...this.getKeys()];\n    return this.getItem(keys[idx]);\n  }\n  getChildren(key) {\n    let node = this.keyMap.get(key);\n    return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n  }\n  constructor(nodes) {\n    this.keyMap = new Map();\n    this.iterable = nodes;\n    let visit = node => {\n      this.keyMap.set(node.key, node);\n      if (node.childNodes && node.type === \"section\") for (let child of node.childNodes) visit(child);\n    };\n    for (let node of nodes) visit(node);\n    let last;\n    let index = 0;\n    for (let [key, node] of this.keyMap) {\n      if (last) {\n        last.nextKey = key;\n        node.prevKey = last.key;\n      } else {\n        this.firstKey = key;\n        node.prevKey = undefined;\n      }\n      if (node.type === \"item\") node.index = index++;\n      last = node;\n      // Set nextKey as undefined since this might be the last node\n      // If it isn't the last node, last.nextKey will properly set at start of new loop\n      last.nextKey = undefined;\n    }\n    this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n  }\n}\nexport { $a02d57049d202695$export$d085fb9e920b5ca7 as ListCollection };","map":{"version":3,"names":["$a02d57049d202695$export$d085fb9e920b5ca7","Symbol","iterator","iterable","size","keyMap","getKeys","keys","getKeyBefore","key","node","get","prevKey","getKeyAfter","nextKey","getFirstKey","firstKey","getLastKey","lastKey","getItem","at","idx","getChildren","childNodes","constructor","nodes","Map","visit","set","type","child","last","index","undefined","ListCollection"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-stately/list/dist/ListCollection.mjs"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ class $a02d57049d202695$export$d085fb9e920b5ca7 {\n    *[Symbol.iterator]() {\n        yield* this.iterable;\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    getKeys() {\n        return this.keyMap.keys();\n    }\n    getKeyBefore(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.prevKey : null;\n    }\n    getKeyAfter(key) {\n        let node = this.keyMap.get(key);\n        return node ? node.nextKey : null;\n    }\n    getFirstKey() {\n        return this.firstKey;\n    }\n    getLastKey() {\n        return this.lastKey;\n    }\n    getItem(key) {\n        return this.keyMap.get(key);\n    }\n    at(idx) {\n        const keys = [\n            ...this.getKeys()\n        ];\n        return this.getItem(keys[idx]);\n    }\n    getChildren(key) {\n        let node = this.keyMap.get(key);\n        return (node === null || node === void 0 ? void 0 : node.childNodes) || [];\n    }\n    constructor(nodes){\n        this.keyMap = new Map();\n        this.iterable = nodes;\n        let visit = (node)=>{\n            this.keyMap.set(node.key, node);\n            if (node.childNodes && node.type === \"section\") for (let child of node.childNodes)visit(child);\n        };\n        for (let node of nodes)visit(node);\n        let last;\n        let index = 0;\n        for (let [key, node] of this.keyMap){\n            if (last) {\n                last.nextKey = key;\n                node.prevKey = last.key;\n            } else {\n                this.firstKey = key;\n                node.prevKey = undefined;\n            }\n            if (node.type === \"item\") node.index = index++;\n            last = node;\n            // Set nextKey as undefined since this might be the last node\n            // If it isn't the last node, last.nextKey will properly set at start of new loop\n            last.nextKey = undefined;\n        }\n        this.lastKey = last === null || last === void 0 ? void 0 : last.key;\n    }\n}\n\n\nexport {$a02d57049d202695$export$d085fb9e920b5ca7 as ListCollection};\n//# sourceMappingURL=ListCollection.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}