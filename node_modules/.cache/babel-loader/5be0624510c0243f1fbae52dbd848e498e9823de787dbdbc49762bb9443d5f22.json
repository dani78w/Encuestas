{"ast":null,"code":"import { hookData as $16f0b7bb276bc17e$export$653eddfc964b0f8a } from \"./useDateField.mjs\";\nimport { useDisplayNames as $3aeceb3a64eb8358$export$d42c60378c8168f8 } from \"./useDisplayNames.mjs\";\nimport { toCalendar as $4d1jn$toCalendar, CalendarDate as $4d1jn$CalendarDate } from \"@internationalized/date\";\nimport { isMac as $4d1jn$isMac, scrollIntoViewport as $4d1jn$scrollIntoViewport, getScrollParent as $4d1jn$getScrollParent, useEvent as $4d1jn$useEvent, useLayoutEffect as $4d1jn$useLayoutEffect, isIOS as $4d1jn$isIOS, useId as $4d1jn$useId, useLabels as $4d1jn$useLabels, mergeProps as $4d1jn$mergeProps } from \"@react-aria/utils\";\nimport { NumberParser as $4d1jn$NumberParser } from \"@internationalized/number\";\nimport $4d1jn$react, { useRef as $4d1jn$useRef, useMemo as $4d1jn$useMemo } from \"react\";\nimport { useLocale as $4d1jn$useLocale, useDateFormatter as $4d1jn$useDateFormatter, useFilter as $4d1jn$useFilter } from \"@react-aria/i18n\";\nimport { useSpinButton as $4d1jn$useSpinButton } from \"@react-aria/spinbutton\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $32489daedd52963e$export$1315d136e6f7581(segment, state, ref) {\n  let enteredKeys = (0, $4d1jn$useRef)(\"\");\n  let {\n    locale: locale\n  } = (0, $4d1jn$useLocale)();\n  let displayNames = (0, $3aeceb3a64eb8358$export$d42c60378c8168f8)();\n  let {\n    ariaLabel: ariaLabel,\n    ariaLabelledBy: ariaLabelledBy,\n    ariaDescribedBy: ariaDescribedBy,\n    focusManager: focusManager\n  } = (0, $16f0b7bb276bc17e$export$653eddfc964b0f8a).get(state);\n  let textValue = segment.isPlaceholder ? \"\" : segment.text;\n  let options = (0, $4d1jn$useMemo)(() => state.dateFormatter.resolvedOptions(), [state.dateFormatter]);\n  let monthDateFormatter = (0, $4d1jn$useDateFormatter)({\n    month: \"long\",\n    timeZone: options.timeZone\n  });\n  let hourDateFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: \"numeric\",\n    hour12: options.hour12,\n    timeZone: options.timeZone\n  });\n  if (segment.type === \"month\" && !segment.isPlaceholder) {\n    let monthTextValue = monthDateFormatter.format(state.dateValue);\n    textValue = monthTextValue !== textValue ? `${textValue} \\u{2013} ${monthTextValue}` : monthTextValue;\n  } else if (segment.type === \"hour\" && !segment.isPlaceholder) textValue = hourDateFormatter.format(state.dateValue);\n  let {\n    spinButtonProps: spinButtonProps\n  } = (0, $4d1jn$useSpinButton)({\n    // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n    // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n    // https://github.com/dequelabs/axe-core/issues/3505\n    value: segment.value,\n    textValue: textValue,\n    minValue: segment.minValue,\n    maxValue: segment.maxValue,\n    isDisabled: state.isDisabled,\n    isReadOnly: state.isReadOnly || !segment.isEditable,\n    isRequired: state.isRequired,\n    onIncrement: () => {\n      enteredKeys.current = \"\";\n      state.increment(segment.type);\n    },\n    onDecrement: () => {\n      enteredKeys.current = \"\";\n      state.decrement(segment.type);\n    },\n    onIncrementPage: () => {\n      enteredKeys.current = \"\";\n      state.incrementPage(segment.type);\n    },\n    onDecrementPage: () => {\n      enteredKeys.current = \"\";\n      state.decrementPage(segment.type);\n    },\n    onIncrementToMax: () => {\n      enteredKeys.current = \"\";\n      state.setSegment(segment.type, segment.maxValue);\n    },\n    onDecrementToMin: () => {\n      enteredKeys.current = \"\";\n      state.setSegment(segment.type, segment.minValue);\n    }\n  });\n  let parser = (0, $4d1jn$useMemo)(() => new (0, $4d1jn$NumberParser)(locale, {\n    maximumFractionDigits: 0\n  }), [locale]);\n  let backspace = () => {\n    if (segment.text === segment.placeholder) focusManager.focusPrevious();\n    if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n      let newValue = segment.text.slice(0, -1);\n      let parsed = parser.parse(newValue);\n      newValue = parsed === 0 ? \"\" : newValue;\n      if (newValue.length === 0 || parsed === 0) state.clearSegment(segment.type);else state.setSegment(segment.type, parsed);\n      enteredKeys.current = newValue;\n    } else if (segment.type === \"dayPeriod\") state.clearSegment(segment.type);\n  };\n  let onKeyDown = e => {\n    // Firefox does not fire selectstart for Ctrl/Cmd + A\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n    if (e.key === \"a\" && ((0, $4d1jn$isMac)() ? e.metaKey : e.ctrlKey)) e.preventDefault();\n    if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;\n    switch (e.key) {\n      case \"Backspace\":\n      case \"Delete\":\n        // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n        e.preventDefault();\n        e.stopPropagation();\n        backspace();\n        break;\n    }\n  };\n  // Safari dayPeriod option doesn't work...\n  let {\n    startsWith: startsWith\n  } = (0, $4d1jn$useFilter)({\n    sensitivity: \"base\"\n  });\n  let amPmFormatter = (0, $4d1jn$useDateFormatter)({\n    hour: \"numeric\",\n    hour12: true\n  });\n  let am = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(0);\n    return amPmFormatter.formatToParts(date).find(part => part.type === \"dayPeriod\").value;\n  }, [amPmFormatter]);\n  let pm = (0, $4d1jn$useMemo)(() => {\n    let date = new Date();\n    date.setHours(12);\n    return amPmFormatter.formatToParts(date).find(part => part.type === \"dayPeriod\").value;\n  }, [amPmFormatter]);\n  // Get a list of formatted era names so users can type the first character to choose one.\n  let eraFormatter = (0, $4d1jn$useDateFormatter)({\n    year: \"numeric\",\n    era: \"narrow\",\n    timeZone: \"UTC\"\n  });\n  let eras = (0, $4d1jn$useMemo)(() => {\n    if (segment.type !== \"era\") return [];\n    let date = (0, $4d1jn$toCalendar)(new (0, $4d1jn$CalendarDate)(1, 1, 1), state.calendar);\n    let eras = state.calendar.getEras().map(era => {\n      let eraDate = date.set({\n        year: 1,\n        month: 1,\n        day: 1,\n        era: era\n      }).toDate(\"UTC\");\n      let parts = eraFormatter.formatToParts(eraDate);\n      let formatted = parts.find(p => p.type === \"era\").value;\n      return {\n        era: era,\n        formatted: formatted\n      };\n    });\n    // Remove the common prefix from formatted values. This is so that in calendars with eras like\n    // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n    // the first letter is used.\n    let prefixLength = $32489daedd52963e$var$commonPrefixLength(eras.map(era => era.formatted));\n    if (prefixLength) for (let era of eras) era.formatted = era.formatted.slice(prefixLength);\n    return eras;\n  }, [eraFormatter, state.calendar, segment.type]);\n  let onInput = key => {\n    if (state.isDisabled || state.isReadOnly) return;\n    let newValue = enteredKeys.current + key;\n    switch (segment.type) {\n      case \"dayPeriod\":\n        if (startsWith(am, key)) state.setSegment(\"dayPeriod\", 0);else if (startsWith(pm, key)) state.setSegment(\"dayPeriod\", 12);else break;\n        focusManager.focusNext();\n        break;\n      case \"era\":\n        {\n          let matched = eras.find(e => startsWith(e.formatted, key));\n          if (matched) {\n            state.setSegment(\"era\", matched.era);\n            focusManager.focusNext();\n          }\n          break;\n        }\n      case \"day\":\n      case \"hour\":\n      case \"minute\":\n      case \"second\":\n      case \"month\":\n      case \"year\":\n        {\n          if (!parser.isValidPartialNumber(newValue)) return;\n          let numberValue = parser.parse(newValue);\n          let segmentValue = numberValue;\n          let allowsZero = segment.minValue === 0;\n          if (segment.type === \"hour\" && state.dateFormatter.resolvedOptions().hour12) {\n            switch (state.dateFormatter.resolvedOptions().hourCycle) {\n              case \"h11\":\n                if (numberValue > 11) segmentValue = parser.parse(key);\n                break;\n              case \"h12\":\n                allowsZero = false;\n                if (numberValue > 12) segmentValue = parser.parse(key);\n                break;\n            }\n            if (segment.value >= 12 && numberValue > 1) numberValue += 12;\n          } else if (numberValue > segment.maxValue) segmentValue = parser.parse(key);\n          if (isNaN(numberValue)) return;\n          let shouldSetValue = segmentValue !== 0 || allowsZero;\n          if (shouldSetValue) state.setSegment(segment.type, segmentValue);\n          if (Number(numberValue + \"0\") > segment.maxValue || newValue.length >= String(segment.maxValue).length) {\n            enteredKeys.current = \"\";\n            if (shouldSetValue) focusManager.focusNext();\n          } else enteredKeys.current = newValue;\n          break;\n        }\n    }\n  };\n  let onFocus = () => {\n    enteredKeys.current = \"\";\n    (0, $4d1jn$scrollIntoViewport)(ref.current, {\n      containingElement: (0, $4d1jn$getScrollParent)(ref.current)\n    });\n    // Collapse selection to start or Chrome won't fire input events.\n    let selection = window.getSelection();\n    selection.collapse(ref.current);\n  };\n  let compositionRef = (0, $4d1jn$useRef)(\"\");\n  // @ts-ignore - TODO: possibly old TS version? doesn't fail in my editor...\n  (0, $4d1jn$useEvent)(ref, \"beforeinput\", e => {\n    e.preventDefault();\n    switch (e.inputType) {\n      case \"deleteContentBackward\":\n      case \"deleteContentForward\":\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) backspace();\n        break;\n      case \"insertCompositionText\":\n        // insertCompositionText cannot be canceled.\n        // Record the current state of the element so we can restore it in the `input` event below.\n        compositionRef.current = ref.current.textContent;\n        // Safari gets stuck in a composition state unless we also assign to the value here.\n        // eslint-disable-next-line no-self-assign\n        ref.current.textContent = ref.current.textContent;\n        break;\n      default:\n        if (e.data != null) onInput(e.data);\n        break;\n    }\n  });\n  (0, $4d1jn$useEvent)(ref, \"input\", e => {\n    let {\n      inputType: inputType,\n      data: data\n    } = e;\n    switch (inputType) {\n      case \"insertCompositionText\":\n        // Reset the DOM to how it was in the beforeinput event.\n        ref.current.textContent = compositionRef.current;\n        // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n        // Can also happen e.g. with Pinyin keyboard on iOS.\n        if (startsWith(am, data) || startsWith(pm, data)) onInput(data);\n        break;\n    }\n  });\n  (0, $4d1jn$useLayoutEffect)(() => {\n    let element = ref.current;\n    return () => {\n      // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n      if (document.activeElement === element) {\n        let prev = focusManager.focusPrevious();\n        if (!prev) focusManager.focusNext();\n      }\n    };\n  }, [ref, focusManager]);\n  // spinbuttons cannot be focused with VoiceOver on iOS.\n  let touchPropOverrides = (0, $4d1jn$isIOS)() || segment.type === \"timeZoneName\" ? {\n    role: \"textbox\",\n    \"aria-valuemax\": null,\n    \"aria-valuemin\": null,\n    \"aria-valuetext\": null,\n    \"aria-valuenow\": null\n  } : {};\n  // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n  // read every time the user navigates to a new segment.\n  let firstSegment = (0, $4d1jn$useMemo)(() => state.segments.find(s => s.isEditable), [state.segments]);\n  if (segment !== firstSegment && !state.isInvalid) ariaDescribedBy = undefined;\n  let id = (0, $4d1jn$useId)();\n  let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n  // Prepend the label passed from the field to each segment name.\n  // This is needed because VoiceOver on iOS does not announce groups.\n  let name = segment.type === \"literal\" ? \"\" : displayNames.of(segment.type);\n  let labelProps = (0, $4d1jn$useLabels)({\n    \"aria-label\": `${name}${ariaLabel ? `, ${ariaLabel}` : \"\"}${ariaLabelledBy ? \", \" : \"\"}`,\n    \"aria-labelledby\": ariaLabelledBy\n  });\n  // Literal segments should not be visible to screen readers. We don't really need any of the above,\n  // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n  if (segment.type === \"literal\") return {\n    segmentProps: {\n      \"aria-hidden\": true\n    }\n  };\n  return {\n    segmentProps: (0, $4d1jn$mergeProps)(spinButtonProps, labelProps, {\n      id: id,\n      ...touchPropOverrides,\n      \"aria-invalid\": state.isInvalid ? \"true\" : undefined,\n      \"aria-describedby\": ariaDescribedBy,\n      \"aria-readonly\": state.isReadOnly || !segment.isEditable ? \"true\" : undefined,\n      \"data-placeholder\": segment.isPlaceholder || undefined,\n      contentEditable: isEditable,\n      suppressContentEditableWarning: isEditable,\n      spellCheck: isEditable ? \"false\" : undefined,\n      autoCapitalize: isEditable ? \"off\" : undefined,\n      autoCorrect: isEditable ? \"off\" : undefined,\n      // Capitalization was changed in React 17...\n      [parseInt((0, $4d1jn$react).version, 10) >= 17 ? \"enterKeyHint\" : \"enterkeyhint\"]: isEditable ? \"next\" : undefined,\n      inputMode: state.isDisabled || segment.type === \"dayPeriod\" || segment.type === \"era\" || !isEditable ? undefined : \"numeric\",\n      tabIndex: state.isDisabled ? undefined : 0,\n      onKeyDown: onKeyDown,\n      onFocus: onFocus,\n      style: {\n        caretColor: \"transparent\"\n      },\n      // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n      onPointerDown(e) {\n        e.stopPropagation();\n      },\n      onMouseDown(e) {\n        e.stopPropagation();\n      }\n    })\n  };\n}\nfunction $32489daedd52963e$var$commonPrefixLength(strings) {\n  // Sort the strings, and compare the characters in the first and last to find the common prefix.\n  strings.sort();\n  let first = strings[0];\n  let last = strings[strings.length - 1];\n  for (let i = 0; i < first.length; i++) {\n    if (first[i] !== last[i]) return i;\n  }\n  return 0;\n}\nexport { $32489daedd52963e$export$1315d136e6f7581 as useDateSegment };","map":{"version":3,"names":["hookData","$16f0b7bb276bc17e$export$653eddfc964b0f8a","useDisplayNames","$3aeceb3a64eb8358$export$d42c60378c8168f8","toCalendar","$4d1jn$toCalendar","CalendarDate","$4d1jn$CalendarDate","isMac","$4d1jn$isMac","scrollIntoViewport","$4d1jn$scrollIntoViewport","getScrollParent","$4d1jn$getScrollParent","useEvent","$4d1jn$useEvent","useLayoutEffect","$4d1jn$useLayoutEffect","isIOS","$4d1jn$isIOS","useId","$4d1jn$useId","useLabels","$4d1jn$useLabels","mergeProps","$4d1jn$mergeProps","NumberParser","$4d1jn$NumberParser","$4d1jn$react","useRef","$4d1jn$useRef","useMemo","$4d1jn$useMemo","useLocale","$4d1jn$useLocale","useDateFormatter","$4d1jn$useDateFormatter","useFilter","$4d1jn$useFilter","useSpinButton","$4d1jn$useSpinButton","$32489daedd52963e$export$1315d136e6f7581","segment","state","ref","enteredKeys","locale","displayNames","ariaLabel","ariaLabelledBy","ariaDescribedBy","focusManager","get","textValue","isPlaceholder","text","options","dateFormatter","resolvedOptions","monthDateFormatter","month","timeZone","hourDateFormatter","hour","hour12","type","monthTextValue","format","dateValue","spinButtonProps","value","minValue","maxValue","isDisabled","isReadOnly","isEditable","isRequired","onIncrement","current","increment","onDecrement","decrement","onIncrementPage","incrementPage","onDecrementPage","decrementPage","onIncrementToMax","setSegment","onDecrementToMin","parser","maximumFractionDigits","backspace","placeholder","focusPrevious","isValidPartialNumber","newValue","slice","parsed","parse","length","clearSegment","onKeyDown","e","key","metaKey","ctrlKey","preventDefault","shiftKey","altKey","stopPropagation","startsWith","sensitivity","amPmFormatter","am","date","Date","setHours","formatToParts","find","part","pm","eraFormatter","year","era","eras","calendar","getEras","map","eraDate","set","day","toDate","parts","formatted","p","prefixLength","$32489daedd52963e$var$commonPrefixLength","onInput","focusNext","matched","numberValue","segmentValue","allowsZero","hourCycle","isNaN","shouldSetValue","Number","String","onFocus","containingElement","selection","window","getSelection","collapse","compositionRef","inputType","textContent","data","element","document","activeElement","prev","touchPropOverrides","role","firstSegment","segments","s","isInvalid","undefined","id","name","of","labelProps","segmentProps","contentEditable","suppressContentEditableWarning","spellCheck","autoCapitalize","autoCorrect","parseInt","version","inputMode","tabIndex","style","caretColor","onPointerDown","onMouseDown","strings","sort","first","last","i","useDateSegment"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-aria/datepicker/dist/useDateSegment.mjs"],"sourcesContent":["import {hookData as $16f0b7bb276bc17e$export$653eddfc964b0f8a} from \"./useDateField.mjs\";\nimport {useDisplayNames as $3aeceb3a64eb8358$export$d42c60378c8168f8} from \"./useDisplayNames.mjs\";\nimport {toCalendar as $4d1jn$toCalendar, CalendarDate as $4d1jn$CalendarDate} from \"@internationalized/date\";\nimport {isMac as $4d1jn$isMac, scrollIntoViewport as $4d1jn$scrollIntoViewport, getScrollParent as $4d1jn$getScrollParent, useEvent as $4d1jn$useEvent, useLayoutEffect as $4d1jn$useLayoutEffect, isIOS as $4d1jn$isIOS, useId as $4d1jn$useId, useLabels as $4d1jn$useLabels, mergeProps as $4d1jn$mergeProps} from \"@react-aria/utils\";\nimport {NumberParser as $4d1jn$NumberParser} from \"@internationalized/number\";\nimport $4d1jn$react, {useRef as $4d1jn$useRef, useMemo as $4d1jn$useMemo} from \"react\";\nimport {useLocale as $4d1jn$useLocale, useDateFormatter as $4d1jn$useDateFormatter, useFilter as $4d1jn$useFilter} from \"@react-aria/i18n\";\nimport {useSpinButton as $4d1jn$useSpinButton} from \"@react-aria/spinbutton\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\n\n\nfunction $32489daedd52963e$export$1315d136e6f7581(segment, state, ref) {\n    let enteredKeys = (0, $4d1jn$useRef)(\"\");\n    let { locale: locale } = (0, $4d1jn$useLocale)();\n    let displayNames = (0, $3aeceb3a64eb8358$export$d42c60378c8168f8)();\n    let { ariaLabel: ariaLabel, ariaLabelledBy: ariaLabelledBy, ariaDescribedBy: ariaDescribedBy, focusManager: focusManager } = (0, $16f0b7bb276bc17e$export$653eddfc964b0f8a).get(state);\n    let textValue = segment.isPlaceholder ? \"\" : segment.text;\n    let options = (0, $4d1jn$useMemo)(()=>state.dateFormatter.resolvedOptions(), [\n        state.dateFormatter\n    ]);\n    let monthDateFormatter = (0, $4d1jn$useDateFormatter)({\n        month: \"long\",\n        timeZone: options.timeZone\n    });\n    let hourDateFormatter = (0, $4d1jn$useDateFormatter)({\n        hour: \"numeric\",\n        hour12: options.hour12,\n        timeZone: options.timeZone\n    });\n    if (segment.type === \"month\" && !segment.isPlaceholder) {\n        let monthTextValue = monthDateFormatter.format(state.dateValue);\n        textValue = monthTextValue !== textValue ? `${textValue} \\u{2013} ${monthTextValue}` : monthTextValue;\n    } else if (segment.type === \"hour\" && !segment.isPlaceholder) textValue = hourDateFormatter.format(state.dateValue);\n    let { spinButtonProps: spinButtonProps } = (0, $4d1jn$useSpinButton)({\n        // The ARIA spec says aria-valuenow is optional if there's no value, but aXe seems to require it.\n        // This doesn't seem to have any negative effects with real AT since we also use aria-valuetext.\n        // https://github.com/dequelabs/axe-core/issues/3505\n        value: segment.value,\n        textValue: textValue,\n        minValue: segment.minValue,\n        maxValue: segment.maxValue,\n        isDisabled: state.isDisabled,\n        isReadOnly: state.isReadOnly || !segment.isEditable,\n        isRequired: state.isRequired,\n        onIncrement: ()=>{\n            enteredKeys.current = \"\";\n            state.increment(segment.type);\n        },\n        onDecrement: ()=>{\n            enteredKeys.current = \"\";\n            state.decrement(segment.type);\n        },\n        onIncrementPage: ()=>{\n            enteredKeys.current = \"\";\n            state.incrementPage(segment.type);\n        },\n        onDecrementPage: ()=>{\n            enteredKeys.current = \"\";\n            state.decrementPage(segment.type);\n        },\n        onIncrementToMax: ()=>{\n            enteredKeys.current = \"\";\n            state.setSegment(segment.type, segment.maxValue);\n        },\n        onDecrementToMin: ()=>{\n            enteredKeys.current = \"\";\n            state.setSegment(segment.type, segment.minValue);\n        }\n    });\n    let parser = (0, $4d1jn$useMemo)(()=>new (0, $4d1jn$NumberParser)(locale, {\n            maximumFractionDigits: 0\n        }), [\n        locale\n    ]);\n    let backspace = ()=>{\n        if (segment.text === segment.placeholder) focusManager.focusPrevious();\n        if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly && !segment.isPlaceholder) {\n            let newValue = segment.text.slice(0, -1);\n            let parsed = parser.parse(newValue);\n            newValue = parsed === 0 ? \"\" : newValue;\n            if (newValue.length === 0 || parsed === 0) state.clearSegment(segment.type);\n            else state.setSegment(segment.type, parsed);\n            enteredKeys.current = newValue;\n        } else if (segment.type === \"dayPeriod\") state.clearSegment(segment.type);\n    };\n    let onKeyDown = (e)=>{\n        // Firefox does not fire selectstart for Ctrl/Cmd + A\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1742153\n        if (e.key === \"a\" && ((0, $4d1jn$isMac)() ? e.metaKey : e.ctrlKey)) e.preventDefault();\n        if (e.ctrlKey || e.metaKey || e.shiftKey || e.altKey) return;\n        switch(e.key){\n            case \"Backspace\":\n            case \"Delete\":\n                // Safari on iOS does not fire beforeinput for the backspace key because the cursor is at the start.\n                e.preventDefault();\n                e.stopPropagation();\n                backspace();\n                break;\n        }\n    };\n    // Safari dayPeriod option doesn't work...\n    let { startsWith: startsWith } = (0, $4d1jn$useFilter)({\n        sensitivity: \"base\"\n    });\n    let amPmFormatter = (0, $4d1jn$useDateFormatter)({\n        hour: \"numeric\",\n        hour12: true\n    });\n    let am = (0, $4d1jn$useMemo)(()=>{\n        let date = new Date();\n        date.setHours(0);\n        return amPmFormatter.formatToParts(date).find((part)=>part.type === \"dayPeriod\").value;\n    }, [\n        amPmFormatter\n    ]);\n    let pm = (0, $4d1jn$useMemo)(()=>{\n        let date = new Date();\n        date.setHours(12);\n        return amPmFormatter.formatToParts(date).find((part)=>part.type === \"dayPeriod\").value;\n    }, [\n        amPmFormatter\n    ]);\n    // Get a list of formatted era names so users can type the first character to choose one.\n    let eraFormatter = (0, $4d1jn$useDateFormatter)({\n        year: \"numeric\",\n        era: \"narrow\",\n        timeZone: \"UTC\"\n    });\n    let eras = (0, $4d1jn$useMemo)(()=>{\n        if (segment.type !== \"era\") return [];\n        let date = (0, $4d1jn$toCalendar)(new (0, $4d1jn$CalendarDate)(1, 1, 1), state.calendar);\n        let eras = state.calendar.getEras().map((era)=>{\n            let eraDate = date.set({\n                year: 1,\n                month: 1,\n                day: 1,\n                era: era\n            }).toDate(\"UTC\");\n            let parts = eraFormatter.formatToParts(eraDate);\n            let formatted = parts.find((p)=>p.type === \"era\").value;\n            return {\n                era: era,\n                formatted: formatted\n            };\n        });\n        // Remove the common prefix from formatted values. This is so that in calendars with eras like\n        // ERA0 and ERA1 (e.g. Ethiopic), users can press \"0\" and \"1\" to select an era. In other cases,\n        // the first letter is used.\n        let prefixLength = $32489daedd52963e$var$commonPrefixLength(eras.map((era)=>era.formatted));\n        if (prefixLength) for (let era of eras)era.formatted = era.formatted.slice(prefixLength);\n        return eras;\n    }, [\n        eraFormatter,\n        state.calendar,\n        segment.type\n    ]);\n    let onInput = (key)=>{\n        if (state.isDisabled || state.isReadOnly) return;\n        let newValue = enteredKeys.current + key;\n        switch(segment.type){\n            case \"dayPeriod\":\n                if (startsWith(am, key)) state.setSegment(\"dayPeriod\", 0);\n                else if (startsWith(pm, key)) state.setSegment(\"dayPeriod\", 12);\n                else break;\n                focusManager.focusNext();\n                break;\n            case \"era\":\n                {\n                    let matched = eras.find((e)=>startsWith(e.formatted, key));\n                    if (matched) {\n                        state.setSegment(\"era\", matched.era);\n                        focusManager.focusNext();\n                    }\n                    break;\n                }\n            case \"day\":\n            case \"hour\":\n            case \"minute\":\n            case \"second\":\n            case \"month\":\n            case \"year\":\n                {\n                    if (!parser.isValidPartialNumber(newValue)) return;\n                    let numberValue = parser.parse(newValue);\n                    let segmentValue = numberValue;\n                    let allowsZero = segment.minValue === 0;\n                    if (segment.type === \"hour\" && state.dateFormatter.resolvedOptions().hour12) {\n                        switch(state.dateFormatter.resolvedOptions().hourCycle){\n                            case \"h11\":\n                                if (numberValue > 11) segmentValue = parser.parse(key);\n                                break;\n                            case \"h12\":\n                                allowsZero = false;\n                                if (numberValue > 12) segmentValue = parser.parse(key);\n                                break;\n                        }\n                        if (segment.value >= 12 && numberValue > 1) numberValue += 12;\n                    } else if (numberValue > segment.maxValue) segmentValue = parser.parse(key);\n                    if (isNaN(numberValue)) return;\n                    let shouldSetValue = segmentValue !== 0 || allowsZero;\n                    if (shouldSetValue) state.setSegment(segment.type, segmentValue);\n                    if (Number(numberValue + \"0\") > segment.maxValue || newValue.length >= String(segment.maxValue).length) {\n                        enteredKeys.current = \"\";\n                        if (shouldSetValue) focusManager.focusNext();\n                    } else enteredKeys.current = newValue;\n                    break;\n                }\n        }\n    };\n    let onFocus = ()=>{\n        enteredKeys.current = \"\";\n        (0, $4d1jn$scrollIntoViewport)(ref.current, {\n            containingElement: (0, $4d1jn$getScrollParent)(ref.current)\n        });\n        // Collapse selection to start or Chrome won't fire input events.\n        let selection = window.getSelection();\n        selection.collapse(ref.current);\n    };\n    let compositionRef = (0, $4d1jn$useRef)(\"\");\n    // @ts-ignore - TODO: possibly old TS version? doesn't fail in my editor...\n    (0, $4d1jn$useEvent)(ref, \"beforeinput\", (e)=>{\n        e.preventDefault();\n        switch(e.inputType){\n            case \"deleteContentBackward\":\n            case \"deleteContentForward\":\n                if (parser.isValidPartialNumber(segment.text) && !state.isReadOnly) backspace();\n                break;\n            case \"insertCompositionText\":\n                // insertCompositionText cannot be canceled.\n                // Record the current state of the element so we can restore it in the `input` event below.\n                compositionRef.current = ref.current.textContent;\n                // Safari gets stuck in a composition state unless we also assign to the value here.\n                // eslint-disable-next-line no-self-assign\n                ref.current.textContent = ref.current.textContent;\n                break;\n            default:\n                if (e.data != null) onInput(e.data);\n                break;\n        }\n    });\n    (0, $4d1jn$useEvent)(ref, \"input\", (e)=>{\n        let { inputType: inputType, data: data } = e;\n        switch(inputType){\n            case \"insertCompositionText\":\n                // Reset the DOM to how it was in the beforeinput event.\n                ref.current.textContent = compositionRef.current;\n                // Android sometimes fires key presses of letters as composition events. Need to handle am/pm keys here too.\n                // Can also happen e.g. with Pinyin keyboard on iOS.\n                if (startsWith(am, data) || startsWith(pm, data)) onInput(data);\n                break;\n        }\n    });\n    (0, $4d1jn$useLayoutEffect)(()=>{\n        let element = ref.current;\n        return ()=>{\n            // If the focused segment is removed, focus the previous one, or the next one if there was no previous one.\n            if (document.activeElement === element) {\n                let prev = focusManager.focusPrevious();\n                if (!prev) focusManager.focusNext();\n            }\n        };\n    }, [\n        ref,\n        focusManager\n    ]);\n    // spinbuttons cannot be focused with VoiceOver on iOS.\n    let touchPropOverrides = (0, $4d1jn$isIOS)() || segment.type === \"timeZoneName\" ? {\n        role: \"textbox\",\n        \"aria-valuemax\": null,\n        \"aria-valuemin\": null,\n        \"aria-valuetext\": null,\n        \"aria-valuenow\": null\n    } : {};\n    // Only apply aria-describedby to the first segment, unless the field is invalid. This avoids it being\n    // read every time the user navigates to a new segment.\n    let firstSegment = (0, $4d1jn$useMemo)(()=>state.segments.find((s)=>s.isEditable), [\n        state.segments\n    ]);\n    if (segment !== firstSegment && !state.isInvalid) ariaDescribedBy = undefined;\n    let id = (0, $4d1jn$useId)();\n    let isEditable = !state.isDisabled && !state.isReadOnly && segment.isEditable;\n    // Prepend the label passed from the field to each segment name.\n    // This is needed because VoiceOver on iOS does not announce groups.\n    let name = segment.type === \"literal\" ? \"\" : displayNames.of(segment.type);\n    let labelProps = (0, $4d1jn$useLabels)({\n        \"aria-label\": `${name}${ariaLabel ? `, ${ariaLabel}` : \"\"}${ariaLabelledBy ? \", \" : \"\"}`,\n        \"aria-labelledby\": ariaLabelledBy\n    });\n    // Literal segments should not be visible to screen readers. We don't really need any of the above,\n    // but the rules of hooks mean hooks cannot be conditional so we have to put this condition here.\n    if (segment.type === \"literal\") return {\n        segmentProps: {\n            \"aria-hidden\": true\n        }\n    };\n    return {\n        segmentProps: (0, $4d1jn$mergeProps)(spinButtonProps, labelProps, {\n            id: id,\n            ...touchPropOverrides,\n            \"aria-invalid\": state.isInvalid ? \"true\" : undefined,\n            \"aria-describedby\": ariaDescribedBy,\n            \"aria-readonly\": state.isReadOnly || !segment.isEditable ? \"true\" : undefined,\n            \"data-placeholder\": segment.isPlaceholder || undefined,\n            contentEditable: isEditable,\n            suppressContentEditableWarning: isEditable,\n            spellCheck: isEditable ? \"false\" : undefined,\n            autoCapitalize: isEditable ? \"off\" : undefined,\n            autoCorrect: isEditable ? \"off\" : undefined,\n            // Capitalization was changed in React 17...\n            [parseInt((0, $4d1jn$react).version, 10) >= 17 ? \"enterKeyHint\" : \"enterkeyhint\"]: isEditable ? \"next\" : undefined,\n            inputMode: state.isDisabled || segment.type === \"dayPeriod\" || segment.type === \"era\" || !isEditable ? undefined : \"numeric\",\n            tabIndex: state.isDisabled ? undefined : 0,\n            onKeyDown: onKeyDown,\n            onFocus: onFocus,\n            style: {\n                caretColor: \"transparent\"\n            },\n            // Prevent pointer events from reaching useDatePickerGroup, and allow native browser behavior to focus the segment.\n            onPointerDown (e) {\n                e.stopPropagation();\n            },\n            onMouseDown (e) {\n                e.stopPropagation();\n            }\n        })\n    };\n}\nfunction $32489daedd52963e$var$commonPrefixLength(strings) {\n    // Sort the strings, and compare the characters in the first and last to find the common prefix.\n    strings.sort();\n    let first = strings[0];\n    let last = strings[strings.length - 1];\n    for(let i = 0; i < first.length; i++){\n        if (first[i] !== last[i]) return i;\n    }\n    return 0;\n}\n\n\nexport {$32489daedd52963e$export$1315d136e6f7581 as useDateSegment};\n//# sourceMappingURL=useDateSegment.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}