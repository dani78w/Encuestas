{"ast":null,"code":"import { isCtrlKeyPressed as $feb5ffebff200149$export$16792effe837dba3, isNonContiguousSelectionModifier as $feb5ffebff200149$export$d3e3bd3e26688c04 } from \"./utils.mjs\";\nimport { useTypeSelect as $fb3050f43d946246$export$e32c88dfddc6e1d8 } from \"./useTypeSelect.mjs\";\nimport { flushSync as $3H3GQ$flushSync } from \"react-dom\";\nimport { useRef as $3H3GQ$useRef, useEffect as $3H3GQ$useEffect } from \"react\";\nimport { getFocusableTreeWalker as $3H3GQ$getFocusableTreeWalker, focusSafely as $3H3GQ$focusSafely } from \"@react-aria/focus\";\nimport { useRouter as $3H3GQ$useRouter, focusWithoutScrolling as $3H3GQ$focusWithoutScrolling, useEvent as $3H3GQ$useEvent, scrollIntoViewport as $3H3GQ$scrollIntoViewport, scrollIntoView as $3H3GQ$scrollIntoView, mergeProps as $3H3GQ$mergeProps } from \"@react-aria/utils\";\nimport { getInteractionModality as $3H3GQ$getInteractionModality } from \"@react-aria/interactions\";\nimport { useLocale as $3H3GQ$useLocale } from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n  let {\n    selectionManager: manager,\n    keyboardDelegate: delegate,\n    ref: ref,\n    autoFocus = false,\n    shouldFocusWrap = false,\n    disallowEmptySelection = false,\n    disallowSelectAll = false,\n    selectOnFocus = manager.selectionBehavior === \"replace\",\n    disallowTypeAhead = false,\n    shouldUseVirtualFocus: shouldUseVirtualFocus,\n    allowsTabNavigation = false,\n    isVirtualized: isVirtualized,\n    // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref,\n    linkBehavior = \"action\"\n  } = options;\n  let {\n    direction: direction\n  } = (0, $3H3GQ$useLocale)();\n  let router = (0, $3H3GQ$useRouter)();\n  let onKeyDown = e => {\n    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n    if (e.altKey && e.key === \"Tab\") e.preventDefault();\n    // Keyboard events bubble through portals. Don't handle keyboard events\n    // for elements outside the collection (e.g. menus).\n    if (!ref.current.contains(e.target)) return;\n    const navigateToKey = (key, childFocus) => {\n      if (key != null) {\n        if (manager.isLink(key) && linkBehavior === \"selection\" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) {\n          // Set focused key and re-render synchronously to bring item into view if needed.\n          (0, $3H3GQ$flushSync)(() => {\n            manager.setFocusedKey(key, childFocus);\n          });\n          let item = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n          let itemProps = manager.getItemProps(key);\n          router.open(item, e, itemProps.href, itemProps.routerOptions);\n          return;\n        }\n        manager.setFocusedKey(key, childFocus);\n        if (manager.isLink(key) && linkBehavior === \"override\") return;\n        if (e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(key);else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);\n      }\n    };\n    switch (e.key) {\n      case \"ArrowDown\":\n        if (delegate.getKeyBelow) {\n          var _delegate_getFirstKey, _delegate_getFirstKey1;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"ArrowUp\":\n        if (delegate.getKeyAbove) {\n          var _delegate_getLastKey, _delegate_getLastKey1;\n          e.preventDefault();\n          let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);\n          if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"ArrowLeft\":\n        if (delegate.getKeyLeftOf) {\n          var _delegate_getFirstKey2, _delegate_getLastKey2;\n          e.preventDefault();\n          let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) nextKey = direction === \"rtl\" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey, direction === \"rtl\" ? \"first\" : \"last\");\n        }\n        break;\n      case \"ArrowRight\":\n        if (delegate.getKeyRightOf) {\n          var _delegate_getLastKey3, _delegate_getFirstKey3;\n          e.preventDefault();\n          let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n          if (nextKey == null && shouldFocusWrap) nextKey = direction === \"rtl\" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);\n          navigateToKey(nextKey, direction === \"rtl\" ? \"last\" : \"first\");\n        }\n        break;\n      case \"Home\":\n        if (delegate.getFirstKey) {\n          e.preventDefault();\n          let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(firstKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(firstKey);else if (selectOnFocus) manager.replaceSelection(firstKey);\n        }\n        break;\n      case \"End\":\n        if (delegate.getLastKey) {\n          e.preventDefault();\n          let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n          manager.setFocusedKey(lastKey);\n          if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(lastKey);else if (selectOnFocus) manager.replaceSelection(lastKey);\n        }\n        break;\n      case \"PageDown\":\n        if (delegate.getKeyPageBelow) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"PageUp\":\n        if (delegate.getKeyPageAbove) {\n          e.preventDefault();\n          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n          navigateToKey(nextKey);\n        }\n        break;\n      case \"a\":\n        if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && manager.selectionMode === \"multiple\" && disallowSelectAll !== true) {\n          e.preventDefault();\n          manager.selectAll();\n        }\n        break;\n      case \"Escape\":\n        if (!disallowEmptySelection && manager.selectedKeys.size !== 0) {\n          e.stopPropagation();\n          e.preventDefault();\n          manager.clearSelection();\n        }\n        break;\n      case \"Tab\":\n        if (!allowsTabNavigation) {\n          // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n          // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n          // in the collection, so that the browser default behavior will apply starting from that element\n          // rather than the currently focused one.\n          if (e.shiftKey) ref.current.focus();else {\n            let walker = (0, $3H3GQ$getFocusableTreeWalker)(ref.current, {\n              tabbable: true\n            });\n            let next;\n            let last;\n            do {\n              last = walker.lastChild();\n              if (last) next = last;\n            } while (last);\n            if (next && !next.contains(document.activeElement)) (0, $3H3GQ$focusWithoutScrolling)(next);\n          }\n          break;\n        }\n    }\n  };\n  // Store the scroll position so we can restore it later.\n  let scrollPos = (0, $3H3GQ$useRef)({\n    top: 0,\n    left: 0\n  });\n  (0, $3H3GQ$useEvent)(scrollRef, \"scroll\", isVirtualized ? null : () => {\n    scrollPos.current = {\n      top: scrollRef.current.scrollTop,\n      left: scrollRef.current.scrollLeft\n    };\n  });\n  let onFocus = e => {\n    if (manager.isFocused) {\n      // If a focus event bubbled through a portal, reset focus state.\n      if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n      return;\n    }\n    // Focus events can bubble through portals. Ignore these events.\n    if (!e.currentTarget.contains(e.target)) return;\n    manager.setFocused(true);\n    if (manager.focusedKey == null) {\n      let navigateToFirstKey = key => {\n        if (key != null) {\n          manager.setFocusedKey(key);\n          if (selectOnFocus) manager.replaceSelection(key);\n        }\n      };\n      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n      // Attempt to detect whether the user is tabbing forward or backward into the collection\n      // and either focus the first or last item accordingly.\n      let relatedTarget = e.relatedTarget;\n      var _manager_lastSelectedKey, _manager_firstSelectedKey;\n      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());\n    } else if (!isVirtualized) {\n      // Restore the scroll position to what it was before.\n      scrollRef.current.scrollTop = scrollPos.current.top;\n      scrollRef.current.scrollLeft = scrollPos.current.left;\n    }\n    if (!isVirtualized && manager.focusedKey != null) {\n      // Refocus and scroll the focused item into view if it exists within the scrollable region.\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`);\n      if (element) {\n        // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n        if (!element.contains(document.activeElement)) (0, $3H3GQ$focusWithoutScrolling)(element);\n        let modality = (0, $3H3GQ$getInteractionModality)();\n        if (modality === \"keyboard\") (0, $3H3GQ$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n  };\n  let onBlur = e => {\n    // Don't set blurred and then focused again if moving focus within the collection.\n    if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n  };\n  const autoFocusRef = (0, $3H3GQ$useRef)(autoFocus);\n  (0, $3H3GQ$useEffect)(() => {\n    if (autoFocusRef.current) {\n      let focusedKey = null;\n      // Check focus strategy to determine which item to focus\n      if (autoFocus === \"first\") focusedKey = delegate.getFirstKey();\n      if (autoFocus === \"last\") focusedKey = delegate.getLastKey();\n      // If there are any selected keys, make the first one the new focus target\n      let selectedKeys = manager.selectedKeys;\n      if (selectedKeys.size) {\n        for (let key of selectedKeys) if (manager.canSelectItem(key)) {\n          focusedKey = key;\n          break;\n        }\n      }\n      manager.setFocused(true);\n      manager.setFocusedKey(focusedKey);\n      // If no default focus key is selected, focus the collection itself.\n      if (focusedKey == null && !shouldUseVirtualFocus) (0, $3H3GQ$focusSafely)(ref.current);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  // If not virtualized, scroll the focused element into view when the focusedKey changes.\n  // When virtualized, Virtualizer handles this internally.\n  let lastFocusedKey = (0, $3H3GQ$useRef)(manager.focusedKey);\n  (0, $3H3GQ$useEffect)(() => {\n    let modality = (0, $3H3GQ$getInteractionModality)();\n    if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n      let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`);\n      if (element && (modality === \"keyboard\" || autoFocusRef.current)) {\n        if (!isVirtualized) (0, $3H3GQ$scrollIntoView)(scrollRef.current, element);\n        // Avoid scroll in iOS VO, since it may cause overlay to close (i.e. RAC submenu)\n        if (modality !== \"virtual\") (0, $3H3GQ$scrollIntoViewport)(element, {\n          containingElement: ref.current\n        });\n      }\n    }\n    // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n    if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $3H3GQ$focusSafely)(ref.current);\n    lastFocusedKey.current = manager.focusedKey;\n    autoFocusRef.current = false;\n  }, [isVirtualized, scrollRef, manager.focusedKey, manager.isFocused, ref]);\n  let handlers = {\n    onKeyDown: onKeyDown,\n    onFocus: onFocus,\n    onBlur: onBlur,\n    onMouseDown(e) {\n      // Ignore events that bubbled through portals.\n      if (scrollRef.current === e.target)\n        // Prevent focus going to the collection when clicking on the scrollbar.\n        e.preventDefault();\n    }\n  };\n  let {\n    typeSelectProps: typeSelectProps\n  } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({\n    keyboardDelegate: delegate,\n    selectionManager: manager\n  });\n  if (!disallowTypeAhead) handlers = (0, $3H3GQ$mergeProps)(typeSelectProps, handlers);\n  // If nothing is focused within the collection, make the collection itself tabbable.\n  // This will be marshalled to either the first or last item depending on where focus came from.\n  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n  // to move real DOM focus to the element anyway.\n  let tabIndex;\n  if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n  return {\n    collectionProps: {\n      ...handlers,\n      tabIndex: tabIndex\n    }\n  };\n}\nexport { $ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection };","map":{"version":3,"names":["isCtrlKeyPressed","$feb5ffebff200149$export$16792effe837dba3","isNonContiguousSelectionModifier","$feb5ffebff200149$export$d3e3bd3e26688c04","useTypeSelect","$fb3050f43d946246$export$e32c88dfddc6e1d8","flushSync","$3H3GQ$flushSync","useRef","$3H3GQ$useRef","useEffect","$3H3GQ$useEffect","getFocusableTreeWalker","$3H3GQ$getFocusableTreeWalker","focusSafely","$3H3GQ$focusSafely","useRouter","$3H3GQ$useRouter","focusWithoutScrolling","$3H3GQ$focusWithoutScrolling","useEvent","$3H3GQ$useEvent","scrollIntoViewport","$3H3GQ$scrollIntoViewport","scrollIntoView","$3H3GQ$scrollIntoView","mergeProps","$3H3GQ$mergeProps","getInteractionModality","$3H3GQ$getInteractionModality","useLocale","$3H3GQ$useLocale","$ae20dd8cbca75726$export$d6daf82dcd84e87c","options","selectionManager","manager","keyboardDelegate","delegate","ref","autoFocus","shouldFocusWrap","disallowEmptySelection","disallowSelectAll","selectOnFocus","selectionBehavior","disallowTypeAhead","shouldUseVirtualFocus","allowsTabNavigation","isVirtualized","scrollRef","linkBehavior","direction","router","onKeyDown","e","altKey","key","preventDefault","current","contains","target","navigateToKey","childFocus","isLink","setFocusedKey","item","querySelector","CSS","escape","toString","itemProps","getItemProps","open","href","routerOptions","shiftKey","selectionMode","extendSelection","replaceSelection","getKeyBelow","_delegate_getFirstKey","_delegate_getFirstKey1","nextKey","focusedKey","getFirstKey","call","getKeyAbove","_delegate_getLastKey","_delegate_getLastKey1","getLastKey","getKeyLeftOf","_delegate_getFirstKey2","_delegate_getLastKey2","getKeyRightOf","_delegate_getLastKey3","_delegate_getFirstKey3","firstKey","lastKey","getKeyPageBelow","getKeyPageAbove","selectAll","selectedKeys","size","stopPropagation","clearSelection","focus","walker","tabbable","next","last","lastChild","document","activeElement","scrollPos","top","left","scrollTop","scrollLeft","onFocus","isFocused","currentTarget","setFocused","navigateToFirstKey","relatedTarget","_manager_lastSelectedKey","_manager_firstSelectedKey","compareDocumentPosition","Node","DOCUMENT_POSITION_FOLLOWING","lastSelectedKey","firstSelectedKey","element","modality","containingElement","onBlur","autoFocusRef","canSelectItem","lastFocusedKey","handlers","onMouseDown","typeSelectProps","tabIndex","collectionProps","useSelectableCollection"],"sources":["/Users/daniel/Documents/Webs/Encuestas/rama-front/Encuestas/node_modules/@react-aria/selection/dist/useSelectableCollection.mjs"],"sourcesContent":["import {isCtrlKeyPressed as $feb5ffebff200149$export$16792effe837dba3, isNonContiguousSelectionModifier as $feb5ffebff200149$export$d3e3bd3e26688c04} from \"./utils.mjs\";\nimport {useTypeSelect as $fb3050f43d946246$export$e32c88dfddc6e1d8} from \"./useTypeSelect.mjs\";\nimport {flushSync as $3H3GQ$flushSync} from \"react-dom\";\nimport {useRef as $3H3GQ$useRef, useEffect as $3H3GQ$useEffect} from \"react\";\nimport {getFocusableTreeWalker as $3H3GQ$getFocusableTreeWalker, focusSafely as $3H3GQ$focusSafely} from \"@react-aria/focus\";\nimport {useRouter as $3H3GQ$useRouter, focusWithoutScrolling as $3H3GQ$focusWithoutScrolling, useEvent as $3H3GQ$useEvent, scrollIntoViewport as $3H3GQ$scrollIntoViewport, scrollIntoView as $3H3GQ$scrollIntoView, mergeProps as $3H3GQ$mergeProps} from \"@react-aria/utils\";\nimport {getInteractionModality as $3H3GQ$getInteractionModality} from \"@react-aria/interactions\";\nimport {useLocale as $3H3GQ$useLocale} from \"@react-aria/i18n\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ \n\n\n\n\n\n\n\nfunction $ae20dd8cbca75726$export$d6daf82dcd84e87c(options) {\n    let { selectionManager: manager, keyboardDelegate: delegate, ref: ref, autoFocus: autoFocus = false, shouldFocusWrap: shouldFocusWrap = false, disallowEmptySelection: disallowEmptySelection = false, disallowSelectAll: disallowSelectAll = false, selectOnFocus: selectOnFocus = manager.selectionBehavior === \"replace\", disallowTypeAhead: disallowTypeAhead = false, shouldUseVirtualFocus: shouldUseVirtualFocus, allowsTabNavigation: allowsTabNavigation = false, isVirtualized: isVirtualized, scrollRef: // If no scrollRef is provided, assume the collection ref is the scrollable region\n    scrollRef = ref, linkBehavior: linkBehavior = \"action\" } = options;\n    let { direction: direction } = (0, $3H3GQ$useLocale)();\n    let router = (0, $3H3GQ$useRouter)();\n    let onKeyDown = (e)=>{\n        // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes\n        if (e.altKey && e.key === \"Tab\") e.preventDefault();\n        // Keyboard events bubble through portals. Don't handle keyboard events\n        // for elements outside the collection (e.g. menus).\n        if (!ref.current.contains(e.target)) return;\n        const navigateToKey = (key, childFocus)=>{\n            if (key != null) {\n                if (manager.isLink(key) && linkBehavior === \"selection\" && selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) {\n                    // Set focused key and re-render synchronously to bring item into view if needed.\n                    (0, $3H3GQ$flushSync)(()=>{\n                        manager.setFocusedKey(key, childFocus);\n                    });\n                    let item = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(key.toString())}\"]`);\n                    let itemProps = manager.getItemProps(key);\n                    router.open(item, e, itemProps.href, itemProps.routerOptions);\n                    return;\n                }\n                manager.setFocusedKey(key, childFocus);\n                if (manager.isLink(key) && linkBehavior === \"override\") return;\n                if (e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(key);\n                else if (selectOnFocus && !(0, $feb5ffebff200149$export$d3e3bd3e26688c04)(e)) manager.replaceSelection(key);\n            }\n        };\n        switch(e.key){\n            case \"ArrowDown\":\n                if (delegate.getKeyBelow) {\n                    var _delegate_getFirstKey, _delegate_getFirstKey1;\n                    e.preventDefault();\n                    let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : (_delegate_getFirstKey = delegate.getFirstKey) === null || _delegate_getFirstKey === void 0 ? void 0 : _delegate_getFirstKey.call(delegate);\n                    if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getFirstKey1 = delegate.getFirstKey) === null || _delegate_getFirstKey1 === void 0 ? void 0 : _delegate_getFirstKey1.call(delegate, manager.focusedKey);\n                    navigateToKey(nextKey);\n                }\n                break;\n            case \"ArrowUp\":\n                if (delegate.getKeyAbove) {\n                    var _delegate_getLastKey, _delegate_getLastKey1;\n                    e.preventDefault();\n                    let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : (_delegate_getLastKey = delegate.getLastKey) === null || _delegate_getLastKey === void 0 ? void 0 : _delegate_getLastKey.call(delegate);\n                    if (nextKey == null && shouldFocusWrap) nextKey = (_delegate_getLastKey1 = delegate.getLastKey) === null || _delegate_getLastKey1 === void 0 ? void 0 : _delegate_getLastKey1.call(delegate, manager.focusedKey);\n                    navigateToKey(nextKey);\n                }\n                break;\n            case \"ArrowLeft\":\n                if (delegate.getKeyLeftOf) {\n                    var _delegate_getFirstKey2, _delegate_getLastKey2;\n                    e.preventDefault();\n                    let nextKey = delegate.getKeyLeftOf(manager.focusedKey);\n                    if (nextKey == null && shouldFocusWrap) nextKey = direction === \"rtl\" ? (_delegate_getFirstKey2 = delegate.getFirstKey) === null || _delegate_getFirstKey2 === void 0 ? void 0 : _delegate_getFirstKey2.call(delegate, manager.focusedKey) : (_delegate_getLastKey2 = delegate.getLastKey) === null || _delegate_getLastKey2 === void 0 ? void 0 : _delegate_getLastKey2.call(delegate, manager.focusedKey);\n                    navigateToKey(nextKey, direction === \"rtl\" ? \"first\" : \"last\");\n                }\n                break;\n            case \"ArrowRight\":\n                if (delegate.getKeyRightOf) {\n                    var _delegate_getLastKey3, _delegate_getFirstKey3;\n                    e.preventDefault();\n                    let nextKey = delegate.getKeyRightOf(manager.focusedKey);\n                    if (nextKey == null && shouldFocusWrap) nextKey = direction === \"rtl\" ? (_delegate_getLastKey3 = delegate.getLastKey) === null || _delegate_getLastKey3 === void 0 ? void 0 : _delegate_getLastKey3.call(delegate, manager.focusedKey) : (_delegate_getFirstKey3 = delegate.getFirstKey) === null || _delegate_getFirstKey3 === void 0 ? void 0 : _delegate_getFirstKey3.call(delegate, manager.focusedKey);\n                    navigateToKey(nextKey, direction === \"rtl\" ? \"last\" : \"first\");\n                }\n                break;\n            case \"Home\":\n                if (delegate.getFirstKey) {\n                    e.preventDefault();\n                    let firstKey = delegate.getFirstKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n                    manager.setFocusedKey(firstKey);\n                    if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(firstKey);\n                    else if (selectOnFocus) manager.replaceSelection(firstKey);\n                }\n                break;\n            case \"End\":\n                if (delegate.getLastKey) {\n                    e.preventDefault();\n                    let lastKey = delegate.getLastKey(manager.focusedKey, (0, $feb5ffebff200149$export$16792effe837dba3)(e));\n                    manager.setFocusedKey(lastKey);\n                    if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && e.shiftKey && manager.selectionMode === \"multiple\") manager.extendSelection(lastKey);\n                    else if (selectOnFocus) manager.replaceSelection(lastKey);\n                }\n                break;\n            case \"PageDown\":\n                if (delegate.getKeyPageBelow) {\n                    e.preventDefault();\n                    let nextKey = delegate.getKeyPageBelow(manager.focusedKey);\n                    navigateToKey(nextKey);\n                }\n                break;\n            case \"PageUp\":\n                if (delegate.getKeyPageAbove) {\n                    e.preventDefault();\n                    let nextKey = delegate.getKeyPageAbove(manager.focusedKey);\n                    navigateToKey(nextKey);\n                }\n                break;\n            case \"a\":\n                if ((0, $feb5ffebff200149$export$16792effe837dba3)(e) && manager.selectionMode === \"multiple\" && disallowSelectAll !== true) {\n                    e.preventDefault();\n                    manager.selectAll();\n                }\n                break;\n            case \"Escape\":\n                if (!disallowEmptySelection && manager.selectedKeys.size !== 0) {\n                    e.stopPropagation();\n                    e.preventDefault();\n                    manager.clearSelection();\n                }\n                break;\n            case \"Tab\":\n                if (!allowsTabNavigation) {\n                    // There may be elements that are \"tabbable\" inside a collection (e.g. in a grid cell).\n                    // However, collections should be treated as a single tab stop, with arrow key navigation internally.\n                    // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.\n                    // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element\n                    // in the collection, so that the browser default behavior will apply starting from that element\n                    // rather than the currently focused one.\n                    if (e.shiftKey) ref.current.focus();\n                    else {\n                        let walker = (0, $3H3GQ$getFocusableTreeWalker)(ref.current, {\n                            tabbable: true\n                        });\n                        let next;\n                        let last;\n                        do {\n                            last = walker.lastChild();\n                            if (last) next = last;\n                        }while (last);\n                        if (next && !next.contains(document.activeElement)) (0, $3H3GQ$focusWithoutScrolling)(next);\n                    }\n                    break;\n                }\n        }\n    };\n    // Store the scroll position so we can restore it later.\n    let scrollPos = (0, $3H3GQ$useRef)({\n        top: 0,\n        left: 0\n    });\n    (0, $3H3GQ$useEvent)(scrollRef, \"scroll\", isVirtualized ? null : ()=>{\n        scrollPos.current = {\n            top: scrollRef.current.scrollTop,\n            left: scrollRef.current.scrollLeft\n        };\n    });\n    let onFocus = (e)=>{\n        if (manager.isFocused) {\n            // If a focus event bubbled through a portal, reset focus state.\n            if (!e.currentTarget.contains(e.target)) manager.setFocused(false);\n            return;\n        }\n        // Focus events can bubble through portals. Ignore these events.\n        if (!e.currentTarget.contains(e.target)) return;\n        manager.setFocused(true);\n        if (manager.focusedKey == null) {\n            let navigateToFirstKey = (key)=>{\n                if (key != null) {\n                    manager.setFocusedKey(key);\n                    if (selectOnFocus) manager.replaceSelection(key);\n                }\n            };\n            // If the user hasn't yet interacted with the collection, there will be no focusedKey set.\n            // Attempt to detect whether the user is tabbing forward or backward into the collection\n            // and either focus the first or last item accordingly.\n            let relatedTarget = e.relatedTarget;\n            var _manager_lastSelectedKey, _manager_firstSelectedKey;\n            if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) navigateToFirstKey((_manager_lastSelectedKey = manager.lastSelectedKey) !== null && _manager_lastSelectedKey !== void 0 ? _manager_lastSelectedKey : delegate.getLastKey());\n            else navigateToFirstKey((_manager_firstSelectedKey = manager.firstSelectedKey) !== null && _manager_firstSelectedKey !== void 0 ? _manager_firstSelectedKey : delegate.getFirstKey());\n        } else if (!isVirtualized) {\n            // Restore the scroll position to what it was before.\n            scrollRef.current.scrollTop = scrollPos.current.top;\n            scrollRef.current.scrollLeft = scrollPos.current.left;\n        }\n        if (!isVirtualized && manager.focusedKey != null) {\n            // Refocus and scroll the focused item into view if it exists within the scrollable region.\n            let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`);\n            if (element) {\n                // This prevents a flash of focus on the first/last element in the collection, or the collection itself.\n                if (!element.contains(document.activeElement)) (0, $3H3GQ$focusWithoutScrolling)(element);\n                let modality = (0, $3H3GQ$getInteractionModality)();\n                if (modality === \"keyboard\") (0, $3H3GQ$scrollIntoViewport)(element, {\n                    containingElement: ref.current\n                });\n            }\n        }\n    };\n    let onBlur = (e)=>{\n        // Don't set blurred and then focused again if moving focus within the collection.\n        if (!e.currentTarget.contains(e.relatedTarget)) manager.setFocused(false);\n    };\n    const autoFocusRef = (0, $3H3GQ$useRef)(autoFocus);\n    (0, $3H3GQ$useEffect)(()=>{\n        if (autoFocusRef.current) {\n            let focusedKey = null;\n            // Check focus strategy to determine which item to focus\n            if (autoFocus === \"first\") focusedKey = delegate.getFirstKey();\n            if (autoFocus === \"last\") focusedKey = delegate.getLastKey();\n            // If there are any selected keys, make the first one the new focus target\n            let selectedKeys = manager.selectedKeys;\n            if (selectedKeys.size) {\n                for (let key of selectedKeys)if (manager.canSelectItem(key)) {\n                    focusedKey = key;\n                    break;\n                }\n            }\n            manager.setFocused(true);\n            manager.setFocusedKey(focusedKey);\n            // If no default focus key is selected, focus the collection itself.\n            if (focusedKey == null && !shouldUseVirtualFocus) (0, $3H3GQ$focusSafely)(ref.current);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    // If not virtualized, scroll the focused element into view when the focusedKey changes.\n    // When virtualized, Virtualizer handles this internally.\n    let lastFocusedKey = (0, $3H3GQ$useRef)(manager.focusedKey);\n    (0, $3H3GQ$useEffect)(()=>{\n        let modality = (0, $3H3GQ$getInteractionModality)();\n        if (manager.isFocused && manager.focusedKey != null && (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current)) {\n            let element = scrollRef.current.querySelector(`[data-key=\"${CSS.escape(manager.focusedKey.toString())}\"]`);\n            if (element && (modality === \"keyboard\" || autoFocusRef.current)) {\n                if (!isVirtualized) (0, $3H3GQ$scrollIntoView)(scrollRef.current, element);\n                // Avoid scroll in iOS VO, since it may cause overlay to close (i.e. RAC submenu)\n                if (modality !== \"virtual\") (0, $3H3GQ$scrollIntoViewport)(element, {\n                    containingElement: ref.current\n                });\n            }\n        }\n        // If the focused key becomes null (e.g. the last item is deleted), focus the whole collection.\n        if (manager.isFocused && manager.focusedKey == null && lastFocusedKey.current != null) (0, $3H3GQ$focusSafely)(ref.current);\n        lastFocusedKey.current = manager.focusedKey;\n        autoFocusRef.current = false;\n    }, [\n        isVirtualized,\n        scrollRef,\n        manager.focusedKey,\n        manager.isFocused,\n        ref\n    ]);\n    let handlers = {\n        onKeyDown: onKeyDown,\n        onFocus: onFocus,\n        onBlur: onBlur,\n        onMouseDown (e) {\n            // Ignore events that bubbled through portals.\n            if (scrollRef.current === e.target) // Prevent focus going to the collection when clicking on the scrollbar.\n            e.preventDefault();\n        }\n    };\n    let { typeSelectProps: typeSelectProps } = (0, $fb3050f43d946246$export$e32c88dfddc6e1d8)({\n        keyboardDelegate: delegate,\n        selectionManager: manager\n    });\n    if (!disallowTypeAhead) handlers = (0, $3H3GQ$mergeProps)(typeSelectProps, handlers);\n    // If nothing is focused within the collection, make the collection itself tabbable.\n    // This will be marshalled to either the first or last item depending on where focus came from.\n    // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try\n    // to move real DOM focus to the element anyway.\n    let tabIndex;\n    if (!shouldUseVirtualFocus) tabIndex = manager.focusedKey == null ? 0 : -1;\n    return {\n        collectionProps: {\n            ...handlers,\n            tabIndex: tabIndex\n        }\n    };\n}\n\n\nexport {$ae20dd8cbca75726$export$d6daf82dcd84e87c as useSelectableCollection};\n//# sourceMappingURL=useSelectableCollection.mjs.map\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}